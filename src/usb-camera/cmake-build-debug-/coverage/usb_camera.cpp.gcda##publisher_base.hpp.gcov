        -:    0:Source:/opt/ros/humble/include/rclcpp/rclcpp/publisher_base.hpp
        -:    0:Graph:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcno
        -:    0:Data:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2014 Open Source Robotics Foundation, Inc.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#ifndef RCLCPP__PUBLISHER_BASE_HPP_
        -:   16:#define RCLCPP__PUBLISHER_BASE_HPP_
        -:   17:
        -:   18:#include <rmw/error_handling.h>
        -:   19:#include <rmw/rmw.h>
        -:   20:
        -:   21:#include <chrono>
        -:   22:#include <functional>
        -:   23:#include <iostream>
        -:   24:#include <memory>
        -:   25:#include <sstream>
        -:   26:#include <string>
        -:   27:#include <unordered_map>
        -:   28:#include <utility>
        -:   29:#include <vector>
        -:   30:
        -:   31:#include "rcl/publisher.h"
        -:   32:
        -:   33:#include "rclcpp/macros.hpp"
        -:   34:#include "rclcpp/network_flow_endpoint.hpp"
        -:   35:#include "rclcpp/qos.hpp"
        -:   36:#include "rclcpp/qos_event.hpp"
        -:   37:#include "rclcpp/type_support_decl.hpp"
        -:   38:#include "rclcpp/visibility_control.hpp"
        -:   39:#include "rcpputils/time.hpp"
        -:   40:
        -:   41:namespace rclcpp
        -:   42:{
        -:   43:
        -:   44:// Forward declaration is used for friend statement.
        -:   45:namespace node_interfaces
        -:   46:{
        -:   47:class NodeBaseInterface;
        -:   48:class NodeTopicsInterface;
        -:   49:}  // namespace node_interfaces
        -:   50:
        -:   51:namespace experimental
        -:   52:{
        -:   53:/**
        -:   54: * IntraProcessManager is forward declared here, avoiding a circular inclusion between
        -:   55: * `intra_process_manager.hpp` and `publisher_base.hpp`.
        -:   56: */
        -:   57:class IntraProcessManager;
        -:   58:}  // namespace experimental
        -:   59:
        -:   60:class PublisherBase : public std::enable_shared_from_this<PublisherBase>
        -:   61:{
        -:   62:  friend ::rclcpp::node_interfaces::NodeTopicsInterface;
        -:   63:
        -:   64:public:
        -:   65:  RCLCPP_SMART_PTR_DEFINITIONS(PublisherBase)
        -:   66:
        -:   67:  /// Default constructor.
        -:   68:  /**
        -:   69:   * Typically, a publisher is not created through this method, but instead is created through a
        -:   70:   * call to `Node::create_publisher`.
        -:   71:   * \param[in] node_base A pointer to the NodeBaseInterface for the parent node.
        -:   72:   * \param[in] topic The topic that this publisher publishes on.
        -:   73:   * \param[in] type_support The type support structure for the type to be published.
        -:   74:   * \param[in] publisher_options QoS settings for this publisher.
        -:   75:   */
        -:   76:  RCLCPP_PUBLIC
        -:   77:  PublisherBase(
        -:   78:    rclcpp::node_interfaces::NodeBaseInterface * node_base,
        -:   79:    const std::string & topic,
        -:   80:    const rosidl_message_type_support_t & type_support,
        -:   81:    const rcl_publisher_options_t & publisher_options);
        -:   82:
        -:   83:  RCLCPP_PUBLIC
        -:   84:  virtual ~PublisherBase();
        -:   85:
        -:   86:  /// Get the topic that this publisher publishes on.
        -:   87:  /** \return The topic name. */
        -:   88:  RCLCPP_PUBLIC
        -:   89:  const char *
        -:   90:  get_topic_name() const;
        -:   91:
        -:   92:  /// Get the queue size for this publisher.
        -:   93:  /** \return The queue size. */
        -:   94:  RCLCPP_PUBLIC
        -:   95:  size_t
        -:   96:  get_queue_size() const;
        -:   97:
        -:   98:  /// Get the global identifier for this publisher (used in rmw and by DDS).
        -:   99:  /** \return The gid. */
        -:  100:  RCLCPP_PUBLIC
        -:  101:  const rmw_gid_t &
        -:  102:  get_gid() const;
        -:  103:
        -:  104:  /// Get the rcl publisher handle.
        -:  105:  /** \return The rcl publisher handle. */
        -:  106:  RCLCPP_PUBLIC
        -:  107:  std::shared_ptr<rcl_publisher_t>
        -:  108:  get_publisher_handle();
        -:  109:
        -:  110:  /// Get the rcl publisher handle.
        -:  111:  /** \return The rcl publisher handle. */
        -:  112:  RCLCPP_PUBLIC
        -:  113:  std::shared_ptr<const rcl_publisher_t>
        -:  114:  get_publisher_handle() const;
        -:  115:
        -:  116:  /// Get all the QoS event handlers associated with this publisher.
        -:  117:  /** \return The map of QoS event handlers. */
        -:  118:  RCLCPP_PUBLIC
        -:  119:  const
        -:  120:  std::unordered_map<rcl_publisher_event_type_t, std::shared_ptr<rclcpp::QOSEventHandlerBase>> &
        -:  121:  get_event_handlers() const;
        -:  122:
        -:  123:  /// Get subscription count
        -:  124:  /** \return The number of subscriptions. */
        -:  125:  RCLCPP_PUBLIC
        -:  126:  size_t
        -:  127:  get_subscription_count() const;
        -:  128:
        -:  129:  /// Get intraprocess subscription count
        -:  130:  /** \return The number of intraprocess subscriptions. */
        -:  131:  RCLCPP_PUBLIC
        -:  132:  size_t
        -:  133:  get_intra_process_subscription_count() const;
        -:  134:
        -:  135:  /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC).
        -:  136:  /**
        -:  137:   * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator
        -:  138:   * of this publisher may manually call `assert_liveliness` at some point in time to signal to the
        -:  139:   * rest of the system that this Node is still alive.
        -:  140:   *
        -:  141:   * \return `true` if the liveliness was asserted successfully, otherwise `false`
        -:  142:   */
        -:  143:  RCLCPP_PUBLIC
        -:  144:  RCUTILS_WARN_UNUSED
        -:  145:  bool
        -:  146:  assert_liveliness() const;
        -:  147:
        -:  148:  /// Get the actual QoS settings, after the defaults have been determined.
        -:  149:  /**
        -:  150:   * The actual configuration applied when using RMW_QOS_POLICY_*_SYSTEM_DEFAULT
        -:  151:   * can only be resolved after the creation of the publisher, and it
        -:  152:   * depends on the underlying rmw implementation.
        -:  153:   * If the underlying setting in use can't be represented in ROS terms,
        -:  154:   * it will be set to RMW_QOS_POLICY_*_UNKNOWN.
        -:  155:   * May throw runtime_error when an unexpected error occurs.
        -:  156:   *
        -:  157:   * \return The actual qos settings.
        -:  158:   */
        -:  159:  RCLCPP_PUBLIC
        -:  160:  rclcpp::QoS
        -:  161:  get_actual_qos() const;
        -:  162:
        -:  163:  /// Check if publisher instance can loan messages.
        -:  164:  /**
        -:  165:   * Depending on the middleware and the message type, this will return true if the middleware
        -:  166:   * can allocate a ROS message instance.
        -:  167:   */
        -:  168:  RCLCPP_PUBLIC
        -:  169:  bool
        -:  170:  can_loan_messages() const;
        -:  171:
        -:  172:  /// Compare this publisher to a gid.
        -:  173:  /**
        -:  174:   * Note that this function calls the next function.
        -:  175:   * \param[in] gid Reference to a gid.
        -:  176:   * \return True if the publisher's gid matches the input.
        -:  177:   */
        -:  178:  RCLCPP_PUBLIC
        -:  179:  bool
        -:  180:  operator==(const rmw_gid_t & gid) const;
        -:  181:
        -:  182:  /// Compare this publisher to a pointer gid.
        -:  183:  /**
        -:  184:   * A wrapper for comparing this publisher's gid to the input using rmw_compare_gids_equal.
        -:  185:   * \param[in] gid A pointer to a gid.
        -:  186:   * \return True if this publisher's gid matches the input.
        -:  187:   */
        -:  188:  RCLCPP_PUBLIC
        -:  189:  bool
        -:  190:  operator==(const rmw_gid_t * gid) const;
        -:  191:
        -:  192:  using IntraProcessManagerSharedPtr =
        -:  193:    std::shared_ptr<rclcpp::experimental::IntraProcessManager>;
        -:  194:
        -:  195:  /// Implementation utility function used to setup intra process publishing after creation.
        -:  196:  RCLCPP_PUBLIC
        -:  197:  void
        -:  198:  setup_intra_process(
        -:  199:    uint64_t intra_process_publisher_id,
        -:  200:    IntraProcessManagerSharedPtr ipm);
        -:  201:
        -:  202:  /// Get network flow endpoints
        -:  203:  /**
        -:  204:   * Describes network flow endpoints that this publisher is sending messages out on
        -:  205:   * \return vector of NetworkFlowEndpoint
        -:  206:   */
        -:  207:  RCLCPP_PUBLIC
        -:  208:  std::vector<rclcpp::NetworkFlowEndpoint>
        -:  209:  get_network_flow_endpoints() const;
        -:  210:
        -:  211:  /// Wait until all published messages are acknowledged or until the specified timeout elapses.
        -:  212:  /**
        -:  213:   * This method waits until all published messages are acknowledged by all matching
        -:  214:   * subscriptions or the given timeout elapses.
        -:  215:   *
        -:  216:   * If the timeout is negative then this method will block indefinitely until all published
        -:  217:   * messages are acknowledged.
        -:  218:   * If the timeout is zero then this method will not block, it will check if all published
        -:  219:   * messages are acknowledged and return immediately.
        -:  220:   * If the timeout is greater than zero, this method will wait until all published messages are
        -:  221:   * acknowledged or the timeout elapses.
        -:  222:   *
        -:  223:   * This method only waits for acknowledgments if the publisher's QoS profile is RELIABLE.
        -:  224:   * Otherwise this method will immediately return `true`.
        -:  225:   *
        -:  226:   * \param[in] timeout the duration to wait for all published messages to be acknowledged.
        -:  227:   * \return `true` if all published messages were acknowledged before the given timeout
        -:  228:   *   elapsed, otherwise `false`.
        -:  229:   * \throws rclcpp::exceptions::RCLError if middleware doesn't support or internal error occurs
        -:  230:   * \throws std::invalid_argument if timeout is greater than std::chrono::nanoseconds::max() or
        -:  231:   *   less than std::chrono::nanoseconds::min()
        -:  232:   */
        -:  233:  template<typename DurationRepT = int64_t, typename DurationT = std::milli>
        -:  234:  bool
        -:  235:  wait_for_all_acked(
        -:  236:    std::chrono::duration<DurationRepT, DurationT> timeout =
        -:  237:    std::chrono::duration<DurationRepT, DurationT>(-1)) const
        -:  238:  {
        -:  239:    rcl_duration_value_t rcl_timeout = rcpputils::convert_to_nanoseconds(timeout).count();
        -:  240:
        -:  241:    rcl_ret_t ret = rcl_publisher_wait_for_all_acked(publisher_handle_.get(), rcl_timeout);
        -:  242:    if (ret == RCL_RET_OK) {
        -:  243:      return true;
        -:  244:    } else if (ret == RCL_RET_TIMEOUT) {
        -:  245:      return false;
        -:  246:    } else {
        -:  247:      rclcpp::exceptions::throw_from_rcl_error(ret);
        -:  248:    }
        -:  249:  }
        -:  250:
        -:  251:  /// Set a callback to be called when each new qos event instance occurs.
        -:  252:  /**
        -:  253:   * The callback receives a size_t which is the number of events that occurred
        -:  254:   * since the last time this callback was called.
        -:  255:   * Normally this is 1, but can be > 1 if events occurred before any
        -:  256:   * callback was set.
        -:  257:   *
        -:  258:   * Since this callback is called from the middleware, you should aim to make
        -:  259:   * it fast and not blocking.
        -:  260:   * If you need to do a lot of work or wait for some other event, you should
        -:  261:   * spin it off to another thread, otherwise you risk blocking the middleware.
        -:  262:   *
        -:  263:   * Calling it again will clear any previously set callback.
        -:  264:   *
        -:  265:   * An exception will be thrown if the callback is not callable.
        -:  266:   *
        -:  267:   * This function is thread-safe.
        -:  268:   *
        -:  269:   * If you want more information available in the callback, like the qos event
        -:  270:   * or other information, you may use a lambda with captures or std::bind.
        -:  271:   *
        -:  272:   * \sa rclcpp::QOSEventHandlerBase::set_on_ready_callback
        -:  273:   *
        -:  274:   * \param[in] callback functor to be called when a new event occurs
        -:  275:   * \param[in] event_type identifier for the qos event we want to attach the callback to
        -:  276:   */
        -:  277:  void
        -:  278:  set_on_new_qos_event_callback(
        -:  279:    std::function<void(size_t)> callback,
        -:  280:    rcl_publisher_event_type_t event_type)
        -:  281:  {
        -:  282:    if (event_handlers_.count(event_type) == 0) {
        -:  283:      RCLCPP_WARN(
        -:  284:        rclcpp::get_logger("rclcpp"),
        -:  285:        "Calling set_on_new_qos_event_callback for non registered publisher event_type");
        -:  286:      return;
        -:  287:    }
        -:  288:
        -:  289:    if (!callback) {
        -:  290:      throw std::invalid_argument(
        -:  291:              "The callback passed to set_on_new_qos_event_callback "
        -:  292:              "is not callable.");
        -:  293:    }
        -:  294:
        -:  295:    // The on_ready_callback signature has an extra `int` argument used to disambiguate between
        -:  296:    // possible different entities within a generic waitable.
        -:  297:    // We hide that detail to users of this method.
        -:  298:    std::function<void(size_t, int)> new_callback = std::bind(callback, std::placeholders::_1);
        -:  299:    event_handlers_[event_type]->set_on_ready_callback(new_callback);
        -:  300:  }
        -:  301:
        -:  302:  /// Unset the callback registered for new qos events, if any.
        -:  303:  void
        -:  304:  clear_on_new_qos_event_callback(rcl_publisher_event_type_t event_type)
        -:  305:  {
        -:  306:    if (event_handlers_.count(event_type) == 0) {
        -:  307:      RCLCPP_WARN(
        -:  308:        rclcpp::get_logger("rclcpp"),
        -:  309:        "Calling clear_on_new_qos_event_callback for non registered event_type");
        -:  310:      return;
        -:  311:    }
        -:  312:
        -:  313:    event_handlers_[event_type]->clear_on_ready_callback();
        -:  314:  }
        -:  315:
        -:  316:protected:
        -:  317:  template<typename EventCallbackT>
        -:  318:  void
       2*:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
       2*:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
       2*:  327:      publisher_handle_,
        -:  328:      event_type);
       2*:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
       2*:  330:  }
------------------
_ZN6rclcpp13PublisherBase17add_event_handlerIZNS_9PublisherIN11sensor_msgs3msg11CameraInfo_ISaIvEEES6_EC4EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS6_EEEUlR35rmw_qos_incompatible_event_status_sE_EEvRKT_26rcl_publisher_event_type_e:
function _ZN6rclcpp13PublisherBase17add_event_handlerIZNS_9PublisherIN11sensor_msgs3msg11CameraInfo_ISaIvEEES6_EC4EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS6_EEEUlR35rmw_qos_incompatible_event_status_sE_EEvRKT_26rcl_publisher_event_type_e called 1 returned 100% blocks executed 58%
        1:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
        1:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
        1:  327:      publisher_handle_,
        1:  327-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  328:      event_type);
        1:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
        1:  329-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  329-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  329-block  2
call    6 returned 1
    $$$$$:  329-block  3
call    7 never executed
    $$$$$:  329-block  4
        1:  330:  }
call    0 returned 1
    $$$$$:  330-block  0
call    1 never executed
------------------
_ZN6rclcpp13PublisherBase17add_event_handlerIZNS_9PublisherIN11sensor_msgs3msg6Image_ISaIvEEES6_EC4EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS6_EEEUlR35rmw_qos_incompatible_event_status_sE_EEvRKT_26rcl_publisher_event_type_e:
function _ZN6rclcpp13PublisherBase17add_event_handlerIZNS_9PublisherIN11sensor_msgs3msg6Image_ISaIvEEES6_EC4EPNS_15node_interfaces17NodeBaseInterfaceERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_3QoSERKNS_29PublisherOptionsWithAllocatorIS6_EEEUlR35rmw_qos_incompatible_event_status_sE_EEvRKT_26rcl_publisher_event_type_e called 1 returned 100% blocks executed 58%
        1:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
        1:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
        1:  327:      publisher_handle_,
        1:  327-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        -:  328:      event_type);
        1:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
        1:  329-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  329-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  329-block  2
call    6 returned 1
    $$$$$:  329-block  3
call    7 never executed
    $$$$$:  329-block  4
        1:  330:  }
call    0 returned 1
    $$$$$:  330-block  0
call    1 never executed
------------------
_ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR35rmw_qos_incompatible_event_status_sEEEEvRKT_26rcl_publisher_event_type_e:
function _ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR35rmw_qos_incompatible_event_status_sEEEEvRKT_26rcl_publisher_event_type_e called 0 returned 0% blocks executed 0%
    #####:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
    #####:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
    #####:  327:      publisher_handle_,
    %%%%%:  327-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  328:      event_type);
    #####:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
    %%%%%:  329-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  329-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:  329-block  2
call    6 never executed
    $$$$$:  329-block  3
call    7 never executed
    $$$$$:  329-block  4
    #####:  330:  }
call    0 never executed
    $$$$$:  330-block  0
call    1 never executed
------------------
_ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR28rmw_liveliness_lost_status_sEEEEvRKT_26rcl_publisher_event_type_e:
function _ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR28rmw_liveliness_lost_status_sEEEEvRKT_26rcl_publisher_event_type_e called 0 returned 0% blocks executed 0%
    #####:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
    #####:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
    #####:  327:      publisher_handle_,
    %%%%%:  327-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  328:      event_type);
    #####:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
    %%%%%:  329-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  329-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:  329-block  2
call    6 never executed
    $$$$$:  329-block  3
call    7 never executed
    $$$$$:  329-block  4
    #####:  330:  }
call    0 never executed
    $$$$$:  330-block  0
call    1 never executed
------------------
_ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR36rmw_offered_deadline_missed_status_sEEEEvRKT_26rcl_publisher_event_type_e:
function _ZN6rclcpp13PublisherBase17add_event_handlerISt8functionIFvR36rmw_offered_deadline_missed_status_sEEEEvRKT_26rcl_publisher_event_type_e called 0 returned 0% blocks executed 0%
    #####:  319:  add_event_handler(
        -:  320:    const EventCallbackT & callback,
        -:  321:    const rcl_publisher_event_type_t event_type)
        -:  322:  {
    #####:  323:    auto handler = std::make_shared<QOSEventHandler<EventCallbackT,
        -:  324:        std::shared_ptr<rcl_publisher_t>>>(
        -:  325:      callback,
        -:  326:      rcl_publisher_event_init,
    #####:  327:      publisher_handle_,
    %%%%%:  327-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  328:      event_type);
    #####:  329:    event_handlers_.insert(std::make_pair(event_type, handler));
    %%%%%:  329-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  329-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:  329-block  2
call    6 never executed
    $$$$$:  329-block  3
call    7 never executed
    $$$$$:  329-block  4
    #####:  330:  }
call    0 never executed
    $$$$$:  330-block  0
call    1 never executed
------------------
        -:  331:
        -:  332:  RCLCPP_PUBLIC
        -:  333:  void default_incompatible_qos_callback(QOSOfferedIncompatibleQoSInfo & info) const;
        -:  334:
        -:  335:  std::shared_ptr<rcl_node_t> rcl_node_handle_;
        -:  336:
        -:  337:  std::shared_ptr<rcl_publisher_t> publisher_handle_;
        -:  338:
        -:  339:  std::unordered_map<rcl_publisher_event_type_t,
        -:  340:    std::shared_ptr<rclcpp::QOSEventHandlerBase>> event_handlers_;
        -:  341:
        -:  342:  using IntraProcessManagerWeakPtr =
        -:  343:    std::weak_ptr<rclcpp::experimental::IntraProcessManager>;
        -:  344:  bool intra_process_is_enabled_;
        -:  345:  IntraProcessManagerWeakPtr weak_ipm_;
        -:  346:  uint64_t intra_process_publisher_id_;
        -:  347:
        -:  348:  rmw_gid_t rmw_gid_;
        -:  349:
        -:  350:  const rosidl_message_type_support_t type_support_;
        -:  351:};
        -:  352:
        -:  353:}  // namespace rclcpp
        -:  354:
        -:  355:#endif  // RCLCPP__PUBLISHER_BASE_HPP_
