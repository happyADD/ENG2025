        -:    0:Source:/opt/ros/humble/include/cv_bridge/cv_bridge/cv_bridge.h
        -:    0:Graph:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcno
        -:    0:Data:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcda
        -:    0:Runs:1
        -:    1:/*********************************************************************
        -:    2:* Software License Agreement (BSD License)
        -:    3:*
        -:    4:*  Copyright (c) 2011, Willow Garage, Inc,
        -:    5:*  Copyright (c) 2015, Tal Regev.
        -:    6:*  Copyright (c) 2018 Intel Corporation.
        -:    7:*  All rights reserved.
        -:    8:*
        -:    9:*  Redistribution and use in source and binary forms, with or without
        -:   10:*  modification, are permitted provided that the following conditions
        -:   11:*  are met:
        -:   12:*
        -:   13:*   * Redistributions of source code must retain the above copyright
        -:   14:*     notice, this list of conditions and the following disclaimer.
        -:   15:*   * Redistributions in binary form must reproduce the above
        -:   16:*     copyright notice, this list of conditions and the following
        -:   17:*     disclaimer in the documentation and/or other materials provided
        -:   18:*     with the distribution.
        -:   19:*   * Neither the name of the Willow Garage nor the names of its
        -:   20:*     contributors may be used to endorse or promote products derived
        -:   21:*     from this software without specific prior written permission.
        -:   22:*
        -:   23:*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        -:   24:*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        -:   25:*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
        -:   26:*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
        -:   27:*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
        -:   28:*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   29:*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   30:*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
        -:   31:*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   32:*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
        -:   33:*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
        -:   34:*  POSSIBILITY OF SUCH DAMAGE.
        -:   35:*********************************************************************/
        -:   36:
        -:   37:#ifndef CV_BRIDGE__CV_BRIDGE_H_
        -:   38:#define CV_BRIDGE__CV_BRIDGE_H_
        -:   39:
        -:   40:#include <sensor_msgs/msg/image.hpp>
        -:   41:#include <sensor_msgs/msg/compressed_image.hpp>
        -:   42:#include <sensor_msgs/image_encodings.hpp>
        -:   43:#include <opencv2/core/core.hpp>
        -:   44:#include <opencv2/imgproc/imgproc.hpp>
        -:   45:#include <opencv2/imgproc/types_c.h>
        -:   46:#include <cv_bridge/cv_bridge_export.h>
        -:   47:
        -:   48:#include <memory>
        -:   49:#include <ostream>
        -:   50:#include <stdexcept>
        -:   51:#include <string>
        -:   52:
        -:   53:namespace cv_bridge
        -:   54:{
        -:   55:
        -:   56:class CV_BRIDGE_EXPORT Exception : public std::runtime_error
        -:   57:{
        -:   58:public:
        -:   59:  explicit Exception(const std::string & description)
        -:   60:  : std::runtime_error(description) {}
        -:   61:};
        -:   62:
        -:   63:class CvImage;
        -:   64:
        -:   65:typedef std::shared_ptr<CvImage> CvImagePtr;
        -:   66:typedef std::shared_ptr<CvImage const> CvImageConstPtr;
        -:   67:
        -:   68:// From: http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#Mat
        -:   69:// imread(const string& filename, int flags)
        -:   70:typedef enum
        -:   71:{
        -:   72:  BMP, DIB,
        -:   73:  JPG, JPEG, JPE,
        -:   74:  JP2,
        -:   75:  PNG,
        -:   76:  PBM, PGM, PPM,
        -:   77:  SR, RAS,
        -:   78:  TIFF, TIF,
        -:   79:} Format;
        -:   80:
        -:   81:/**
        -:   82: * \brief Image message class that is interoperable with sensor_msgs/Image but uses a
        -:   83: * more convenient cv::Mat representation for the image data.
        -:   84: */
        -:   85:class CV_BRIDGE_EXPORT CvImage
        -:   86:{
        -:   87:public:
        -:   88:  std_msgs::msg::Header header;  // !< ROS header
        -:   89:  std::string encoding;    // !< Image encoding ("mono8", "bgr8", etc.)
        -:   90:  cv::Mat image;           // !< Image data for use with OpenCV
        -:   91:
        -:   92:  /**
        -:   93:   * \brief Empty constructor.
        -:   94:   */
function _ZN9cv_bridge7CvImageC2Ev called 34 returned 100% blocks executed 100%
       34:   95:  CvImage() {}
       34:   95-block  0
call    0 returned 34
call    1 returned 34
call    2 returned 34
call    3 returned 34
        -:   96:
        -:   97:  /**
        -:   98:   * \brief Constructor.
        -:   99:   */
        -:  100:  CvImage(
        -:  101:    const std_msgs::msg::Header & header, const std::string & encoding,
        -:  102:    const cv::Mat & image = cv::Mat())
        -:  103:  : header(header), encoding(encoding), image(image)
        -:  104:  {
        -:  105:  }
        -:  106:
        -:  107:  /**
        -:  108:   * \brief Convert this message to a ROS sensor_msgs::msg::Image message.
        -:  109:   *
        -:  110:   * The returned sensor_msgs::msg::Image message contains a copy of the image data.
        -:  111:   */
        -:  112:  sensor_msgs::msg::Image::SharedPtr toImageMsg() const;
        -:  113:
        -:  114:  /**
        -:  115:   * dst_format is compress the image to desire format.
        -:  116:   * Default value is empty string that will convert to jpg format.
        -:  117:   * can be: jpg, jp2, bmp, png, tif at the moment
        -:  118:   * support this format from opencv:
        -:  119:   * http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#Mat imread(const string& filename, int flags)
        -:  120:   */
        -:  121:  sensor_msgs::msg::CompressedImage::SharedPtr toCompressedImageMsg(
        -:  122:    const Format dst_format =
        -:  123:    JPG) const;
        -:  124:
        -:  125:  /**
        -:  126:   * \brief Copy the message data to a ROS sensor_msgs::msg::Image message.
        -:  127:   *
        -:  128:   * This overload is intended mainly for aggregate messages such as stereo_msgs::DisparityImage,
        -:  129:   * which contains a sensor_msgs::msg::Image as a data member.
        -:  130:   */
        -:  131:  void toImageMsg(sensor_msgs::msg::Image & ros_image) const;
        -:  132:
        -:  133:  /**
        -:  134:   * dst_format is compress the image to desire format.
        -:  135:   * Default value is empty string that will convert to jpg format.
        -:  136:   * can be: jpg, jp2, bmp, png, tif at the moment
        -:  137:   * support this format from opencv:
        -:  138:   * http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html#Mat imread(const string& filename, int flags)
        -:  139:   */
        -:  140:  void toCompressedImageMsg(
        -:  141:    sensor_msgs::msg::CompressedImage & ros_image,
        -:  142:    const Format dst_format = JPG) const;
        -:  143:
        -:  144:
        -:  145:  typedef std::shared_ptr<CvImage> Ptr;
        -:  146:  typedef std::shared_ptr<CvImage const> ConstPtr;
        -:  147:
        -:  148:protected:
        -:  149:  std::shared_ptr<void const> tracked_object_;  // for sharing ownership
        -:  150:
        -:  151:  /// @cond DOXYGEN_IGNORE
        -:  152:  friend
        -:  153:  CV_BRIDGE_EXPORT CvImageConstPtr toCvShare(
        -:  154:    const sensor_msgs::msg::Image & source,
        -:  155:    const std::shared_ptr<void const> & tracked_object,
        -:  156:    const std::string & encoding);
        -:  157:  /// @endcond
        -:  158:};
        -:  159:
        -:  160:
        -:  161:/**
        -:  162: * \brief Convert a sensor_msgs::msg::Image message to an OpenCV-compatible CvImage, copying the
        -:  163: * image data.
        -:  164: *
        -:  165: * \param source   A shared_ptr to a sensor_msgs::msg::Image message
        -:  166: * \param encoding The desired encoding of the image data, one of the following strings:
        -:  167: *    - \c "mono8"
        -:  168: *    - \c "bgr8"
        -:  169: *    - \c "bgra8"
        -:  170: *    - \c "rgb8"
        -:  171: *    - \c "rgba8"
        -:  172: *    - \c "mono16"
        -:  173: *
        -:  174: * If \a encoding is the empty string (the default), the returned CvImage has the same encoding
        -:  175: * as \a source.
        -:  176: */
        -:  177:CV_BRIDGE_EXPORT CvImagePtr toCvCopy(
        -:  178:  const sensor_msgs::msg::Image::ConstSharedPtr & source,
        -:  179:  const std::string & encoding = std::string());
        -:  180:
        -:  181:CV_BRIDGE_EXPORT CvImagePtr toCvCopy(
        -:  182:  const sensor_msgs::msg::CompressedImage::ConstSharedPtr & source,
        -:  183:  const std::string & encoding = std::string());
        -:  184:
        -:  185:/**
        -:  186: * \brief Convert a sensor_msgs::msg::Image message to an OpenCV-compatible CvImage, copying the
        -:  187: * image data.
        -:  188: *
        -:  189: * \param source   A sensor_msgs::msg::Image message
        -:  190: * \param encoding The desired encoding of the image data, one of the following strings:
        -:  191: *    - \c "mono8"
        -:  192: *    - \c "bgr8"
        -:  193: *    - \c "bgra8"
        -:  194: *    - \c "rgb8"
        -:  195: *    - \c "rgba8"
        -:  196: *    - \c "mono16"
        -:  197: *
        -:  198: * If \a encoding is the empty string (the default), the returned CvImage has the same encoding
        -:  199: * as \a source.
        -:  200: * If the source is 8bit and the encoding 16 or vice-versa, a scaling is applied (65535/255 and
        -:  201: * 255/65535 respectively). Otherwise, no scaling is applied and the rules from the convertTo OpenCV
        -:  202: * function are applied (capping): http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto
        -:  203: */
        -:  204:CV_BRIDGE_EXPORT CvImagePtr toCvCopy(
        -:  205:  const sensor_msgs::msg::Image & source,
        -:  206:  const std::string & encoding = std::string());
        -:  207:
        -:  208:CV_BRIDGE_EXPORT CvImagePtr toCvCopy(
        -:  209:  const sensor_msgs::msg::CompressedImage & source,
        -:  210:  const std::string & encoding = std::string());
        -:  211:
        -:  212:/**
        -:  213: * \brief Convert an immutable sensor_msgs::msg::Image message to an OpenCV-compatible CvImage, sharing
        -:  214: * the image data if possible.
        -:  215: *
        -:  216: * If the source encoding and desired encoding are the same, the returned CvImage will share
        -:  217: * the image data with \a source without copying it. The returned CvImage cannot be modified, as that
        -:  218: * could modify the \a source data.
        -:  219: *
        -:  220: * \param source   A shared_ptr to a sensor_msgs::msg::Image message
        -:  221: * \param encoding The desired encoding of the image data, one of the following strings:
        -:  222: *    - \c "mono8"
        -:  223: *    - \c "bgr8"
        -:  224: *    - \c "bgra8"
        -:  225: *    - \c "rgb8"
        -:  226: *    - \c "rgba8"
        -:  227: *    - \c "mono16"
        -:  228: *
        -:  229: * If \a encoding is the empty string (the default), the returned CvImage has the same encoding
        -:  230: * as \a source.
        -:  231: */
        -:  232:CV_BRIDGE_EXPORT CvImageConstPtr toCvShare(
        -:  233:  const sensor_msgs::msg::Image::ConstSharedPtr & source,
        -:  234:  const std::string & encoding = std::string());
        -:  235:
        -:  236:/**
        -:  237: * \brief Convert an immutable sensor_msgs::msg::Image message to an OpenCV-compatible CvImage, sharing
        -:  238: * the image data if possible.
        -:  239: *
        -:  240: * If the source encoding and desired encoding are the same, the returned CvImage will share
        -:  241: * the image data with \a source without copying it. The returned CvImage cannot be modified, as that
        -:  242: * could modify the \a source data.
        -:  243: *
        -:  244: * This overload is useful when you have a shared_ptr to a message that contains a
        -:  245: * sensor_msgs::msg::Image, and wish to share ownership with the containing message.
        -:  246: *
        -:  247: * \param source         The sensor_msgs::msg::Image message
        -:  248: * \param tracked_object A shared_ptr to an object owning the sensor_msgs::msg::Image
        -:  249: * \param encoding       The desired encoding of the image data, one of the following strings:
        -:  250: *    - \c "mono8"
        -:  251: *    - \c "bgr8"
        -:  252: *    - \c "bgra8"
        -:  253: *    - \c "rgb8"
        -:  254: *    - \c "rgba8"
        -:  255: *    - \c "mono16"
        -:  256: *
        -:  257: * If \a encoding is the empty string (the default), the returned CvImage has the same encoding
        -:  258: * as \a source.
        -:  259: */
        -:  260:CV_BRIDGE_EXPORT CvImageConstPtr toCvShare(
        -:  261:  const sensor_msgs::msg::Image & source,
        -:  262:  const std::shared_ptr<void const> & tracked_object,
        -:  263:  const std::string & encoding = std::string());
        -:  264:
        -:  265:/**
        -:  266: * \brief Convert a CvImage to another encoding using the same rules as toCvCopy
        -:  267: */
        -:  268:CV_BRIDGE_EXPORT CvImagePtr cvtColor(
        -:  269:  const CvImageConstPtr & source,
        -:  270:  const std::string & encoding);
        -:  271:
        -:  272:struct CvtColorForDisplayOptions
        -:  273:{
        -:  274:  CvtColorForDisplayOptions()
        -:  275:  : do_dynamic_scaling(false),
        -:  276:    min_image_value(0.0),
        -:  277:    max_image_value(0.0),
        -:  278:    colormap(-1),
        -:  279:    bg_label(-1) {}
        -:  280:  bool do_dynamic_scaling;
        -:  281:  double min_image_value;
        -:  282:  double max_image_value;
        -:  283:  int colormap;
        -:  284:  int bg_label;
        -:  285:};
        -:  286:
        -:  287:
        -:  288:/**
        -:  289: * \brief Converts an immutable sensor_msgs::msg::Image message to another CvImage for display purposes,
        -:  290: * using practical conversion rules if needed.
        -:  291: *
        -:  292: * Data will be shared between input and output if possible.
        -:  293: *
        -:  294: * Recall: sensor_msgs::msg::image_encodings::isColor and isMono tell whether an image contains R,G,B,A, mono
        -:  295: * (or any combination/subset) with 8 or 16 bit depth.
        -:  296: *
        -:  297: * The following rules apply:
        -:  298: * - if the output encoding is empty, the fact that the input image is mono or multiple-channel is
        -:  299: * preserved in the ouput image. The bit depth will be 8. it tries to convert to BGR no matter what
        -:  300: * encoding image is passed.
        -:  301: * - if the output encoding is not empty, it must have sensor_msgs::msg::image_encodings::isColor and
        -:  302: * isMono return true. It must also be 8 bit in depth
        -:  303: * - if the input encoding is an OpenCV format (e.g. 8UC1), and if we have 1,3 or 4 channels, it is
        -:  304: * respectively converted to mono, BGR or BGRA.
        -:  305: * - if the input encoding is 32SC1, this estimate that image as label image and will convert it as
        -:  306: * bgr image with different colors for each label.
        -:  307: *
        -:  308: * \param source   A shared_ptr to a sensor_msgs::msg::Image message
        -:  309: * \param encoding Either an encoding string that returns true in sensor_msgs::msg::image_encodings::isColor
        -:  310: * isMono or the empty string as explained above.
        -:  311: * \param options (cv_bridge::CvtColorForDisplayOptions) Options to convert the source image with.
        -:  312: * - do_dynamic_scaling If true, the image is dynamically scaled between its minimum and maximum value
        -:  313: * before being converted to its final encoding.
        -:  314: * - min_image_value Independently from do_dynamic_scaling, if min_image_value and max_image_value are
        -:  315: * different, the image is scaled between these two values before being converted to its final encoding.
        -:  316: * - max_image_value Maximum image value
        -:  317: * - colormap Colormap which the source image converted with.
        -:  318: */
        -:  319:CV_BRIDGE_EXPORT CvImageConstPtr cvtColorForDisplay(
        -:  320:  const CvImageConstPtr & source,
        -:  321:  const std::string & encoding = std::string(),
        -:  322:  const CvtColorForDisplayOptions options = CvtColorForDisplayOptions());
        -:  323:
        -:  324:/**
        -:  325: * \brief Get the OpenCV type enum corresponding to the encoding.
        -:  326: *
        -:  327: * For example, "bgr8" -> CV_8UC3, "32FC1" -> CV_32FC1, and "32FC10" -> CV_32FC10.
        -:  328: */
        -:  329:CV_BRIDGE_EXPORT int getCvType(const std::string & encoding);
        -:  330:
        -:  331:}  // namespace cv_bridge
        -:  332:
        -:  333:#endif  // CV_BRIDGE__CV_BRIDGE_H_
