        -:    0:Source:/opt/ros/humble/include/rclcpp/rclcpp/context.hpp
        -:    0:Graph:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcno
        -:    0:Data:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2014 Open Source Robotics Foundation, Inc.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#ifndef RCLCPP__CONTEXT_HPP_
        -:   16:#define RCLCPP__CONTEXT_HPP_
        -:   17:
        -:   18:#include <condition_variable>
        -:   19:#include <functional>
        -:   20:#include <memory>
        -:   21:#include <mutex>
        -:   22:#include <string>
        -:   23:#include <typeindex>
        -:   24:#include <typeinfo>
        -:   25:#include <unordered_map>
        -:   26:#include <unordered_set>
        -:   27:#include <utility>
        -:   28:#include <vector>
        -:   29:#include <stdexcept>
        -:   30:
        -:   31:#include "rcl/context.h"
        -:   32:#include "rcl/guard_condition.h"
        -:   33:#include "rcl/wait.h"
        -:   34:#include "rclcpp/init_options.hpp"
        -:   35:#include "rclcpp/macros.hpp"
        -:   36:#include "rclcpp/visibility_control.hpp"
        -:   37:
        -:   38:namespace rclcpp
        -:   39:{
        -:   40:
        -:   41:/// Thrown when init is called on an already initialized context.
        -:   42:class ContextAlreadyInitialized : public std::runtime_error
        -:   43:{
        -:   44:public:
        -:   45:  ContextAlreadyInitialized()
        -:   46:  : std::runtime_error("context is already initialized") {}
        -:   47:};
        -:   48:
        -:   49:/// Forward declare WeakContextsWrapper
        -:   50:class WeakContextsWrapper;
        -:   51:
        -:   52:class ShutdownCallbackHandle
        -:   53:{
        -:   54:  friend class Context;
        -:   55:
        -:   56:public:
        -:   57:  using ShutdownCallbackType = std::function<void ()>;
        -:   58:
        -:   59:private:
        -:   60:  std::weak_ptr<ShutdownCallbackType> callback;
        -:   61:};
        -:   62:
        -:   63:using OnShutdownCallbackHandle = ShutdownCallbackHandle;
        -:   64:using PreShutdownCallbackHandle = ShutdownCallbackHandle;
        -:   65:
        -:   66:/// Context which encapsulates shared state between nodes and other similar entities.
        -:   67:/**
        -:   68: * A context also represents the lifecycle between init and shutdown of rclcpp.
        -:   69: * It is often used in conjunction with rclcpp::init, or rclcpp::init_local,
        -:   70: * and rclcpp::shutdown.
        -:   71: */
        -:   72:class Context : public std::enable_shared_from_this<Context>
        -:   73:{
        -:   74:public:
        -:   75:  RCLCPP_SMART_PTR_DEFINITIONS(Context)
        -:   76:
        -:   77:  /// Default constructor, after which the Context is still not "initialized".
        -:   78:  /**
        -:   79:   * Every context which is constructed is added to a global vector of contexts,
        -:   80:   * which is used by the signal handler to conditionally shutdown each context
        -:   81:   * on SIGINT.
        -:   82:   * See the shutdown_on_signal option in the InitOptions class.
        -:   83:   */
        -:   84:  RCLCPP_PUBLIC
        -:   85:  Context();
        -:   86:
        -:   87:  RCLCPP_PUBLIC
        -:   88:  virtual
        -:   89:  ~Context();
        -:   90:
        -:   91:  /// Initialize the context, and the underlying elements like the rcl context.
        -:   92:  /**
        -:   93:   * This method must be called before passing this context to things like the
        -:   94:   * constructor of Node.
        -:   95:   * It must also be called before trying to shutdown the context.
        -:   96:   *
        -:   97:   * Note that this function does not setup any signal handlers, so if you want
        -:   98:   * it to be shutdown by the signal handler, then you need to either install
        -:   99:   * them manually with rclcpp::install_signal_handlers() or use rclcpp::init().
        -:  100:   * In addition to installing the signal handlers, the shutdown_on_signal
        -:  101:   * of the InitOptions needs to be `true` for this context to be shutdown by
        -:  102:   * the signal handler, otherwise it will be passed over.
        -:  103:   *
        -:  104:   * After calling this method, shutdown() can be called to invalidate the
        -:  105:   * context for derived entities, e.g. nodes, guard conditions, etc.
        -:  106:   * However, the underlying rcl context is not finalized until this Context's
        -:  107:   * destructor is called or this function is called again.
        -:  108:   * Allowing this class to go out of scope and get destructed or calling this
        -:  109:   * function a second time while derived entities are still using the context
        -:  110:   * is undefined behavior and should be avoided.
        -:  111:   * It's a good idea to not reuse context objects and instead create a new one
        -:  112:   * each time you need to shutdown and init again.
        -:  113:   * This allows derived entities to hold on to shard pointers to the first
        -:  114:   * context object until they are done.
        -:  115:   *
        -:  116:   * This function is thread-safe.
        -:  117:   *
        -:  118:   * \param[in] argc number of arguments
        -:  119:   * \param[in] argv argument array which may contain arguments intended for ROS
        -:  120:   * \param[in] init_options initialization options for rclcpp and underlying layers
        -:  121:   * \throw ContextAlreadyInitialized if called if init is called more than once
        -:  122:   * \throws anything rclcpp::exceptions::throw_from_rcl_error can throw.
        -:  123:   * \throws std::runtime_error if the global logging configure mutex is NULL
        -:  124:   * \throws exceptions::UnknownROSArgsError if there are unknown ROS arguments
        -:  125:   */
        -:  126:  RCLCPP_PUBLIC
        -:  127:  virtual
        -:  128:  void
        -:  129:  init(
        -:  130:    int argc,
        -:  131:    char const * const * argv,
        -:  132:    const rclcpp::InitOptions & init_options = rclcpp::InitOptions());
        -:  133:
        -:  134:  /// Return true if the context is valid, otherwise false.
        -:  135:  /**
        -:  136:   * The context is valid if it has been initialized but not shutdown.
        -:  137:   *
        -:  138:   * This function is thread-safe.
        -:  139:   * This function is lock free so long as pointers and uint64_t atomics are
        -:  140:   * lock free.
        -:  141:   *
        -:  142:   * \return true if valid, otherwise false
        -:  143:   */
        -:  144:  RCLCPP_PUBLIC
        -:  145:  bool
        -:  146:  is_valid() const;
        -:  147:
        -:  148:  /// Return the init options used during init.
        -:  149:  RCLCPP_PUBLIC
        -:  150:  const rclcpp::InitOptions &
        -:  151:  get_init_options() const;
        -:  152:
        -:  153:  /// Return a copy of the init options used during init.
        -:  154:  RCLCPP_PUBLIC
        -:  155:  rclcpp::InitOptions
        -:  156:  get_init_options();
        -:  157:
        -:  158:  /// Return actual domain id.
        -:  159:  RCLCPP_PUBLIC
        -:  160:  size_t
        -:  161:  get_domain_id() const;
        -:  162:
        -:  163:  /// Return the shutdown reason, or empty string if not shutdown.
        -:  164:  /**
        -:  165:   * This function is thread-safe.
        -:  166:   */
        -:  167:  RCLCPP_PUBLIC
        -:  168:  std::string
        -:  169:  shutdown_reason() const;
        -:  170:
        -:  171:  /// Shutdown the context, making it uninitialized and therefore invalid for derived entities.
        -:  172:  /**
        -:  173:   * Several things happen when the context is shutdown, in this order:
        -:  174:   *
        -:  175:   * - acquires a lock to prevent race conditions with init, on_shutdown, etc.
        -:  176:   * - if the context is not initialized, return false
        -:  177:   * - rcl_shutdown() is called on the internal rcl_context_t instance
        -:  178:   * - the shutdown reason is set
        -:  179:   * - each on_shutdown callback is called, in the order that they were added
        -:  180:   * - interrupt blocking sleep_for() calls, so they return early due to shutdown
        -:  181:   * - interrupt blocking executors and wait sets
        -:  182:   *
        -:  183:   * The underlying rcl context is not finalized by this function.
        -:  184:   *
        -:  185:   * This function is thread-safe.
        -:  186:   *
        -:  187:   * \param[in] reason the description of why shutdown happened
        -:  188:   * \return true if shutdown was successful, false if context was already shutdown
        -:  189:   * \throw various exceptions derived from rclcpp::exceptions::RCLError, if rcl_shutdown fails
        -:  190:   */
        -:  191:  RCLCPP_PUBLIC
        -:  192:  virtual
        -:  193:  bool
        -:  194:  shutdown(const std::string & reason);
        -:  195:
        -:  196:  using OnShutdownCallback = OnShutdownCallbackHandle::ShutdownCallbackType;
        -:  197:
        -:  198:  /// Add a on_shutdown callback to be called when shutdown is called for this context.
        -:  199:  /**
        -:  200:   * These callbacks will be called in the order they are added as the second
        -:  201:   * to last step in shutdown().
        -:  202:   *
        -:  203:   * When shutdown occurs due to the signal handler, these callbacks are run
        -:  204:   * asynchronously in the dedicated singal handling thread.
        -:  205:   *
        -:  206:   * Also, shutdown() may be called from the destructor of this function.
        -:  207:   * Therefore, it is not safe to throw exceptions from these callbacks.
        -:  208:   * Instead, log errors or use some other mechanism to indicate an error has
        -:  209:   * occurred.
        -:  210:   *
        -:  211:   * On shutdown callbacks may be registered before init and after shutdown,
        -:  212:   * and persist on repeated init's.
        -:  213:   *
        -:  214:   * \param[in] callback the on shutdown callback to be registered
        -:  215:   * \return the callback passed, for convenience when storing a passed lambda
        -:  216:   */
        -:  217:  RCLCPP_PUBLIC
        -:  218:  virtual
        -:  219:  OnShutdownCallback
        -:  220:  on_shutdown(OnShutdownCallback callback);
        -:  221:
        -:  222:  /// Add a on_shutdown callback to be called when shutdown is called for this context.
        -:  223:  /**
        -:  224:   * These callbacks will be called in the order they are added as the second
        -:  225:   * to last step in shutdown().
        -:  226:   *
        -:  227:   * When shutdown occurs due to the signal handler, these callbacks are run
        -:  228:   * asynchronously in the dedicated signal handling thread.
        -:  229:   *
        -:  230:   * Also, shutdown() may be called from the destructor of this function.
        -:  231:   * Therefore, it is not safe to throw exceptions from these callbacks.
        -:  232:   * Instead, log errors or use some other mechanism to indicate an error has
        -:  233:   * occurred.
        -:  234:   *
        -:  235:   * On shutdown callbacks may be registered before init and after shutdown,
        -:  236:   * and persist on repeated init's.
        -:  237:   *
        -:  238:   * \param[in] callback the on_shutdown callback to be registered
        -:  239:   * \return the created callback handle
        -:  240:   */
        -:  241:  RCLCPP_PUBLIC
        -:  242:  virtual
        -:  243:  OnShutdownCallbackHandle
        -:  244:  add_on_shutdown_callback(OnShutdownCallback callback);
        -:  245:
        -:  246:  /// Remove an registered on_shutdown callbacks.
        -:  247:  /**
        -:  248:   * \param[in] callback_handle the on_shutdown callback handle to be removed.
        -:  249:   * \return true if the callback is found and removed, otherwise false.
        -:  250:   */
        -:  251:  RCLCPP_PUBLIC
        -:  252:  virtual
        -:  253:  bool
        -:  254:  remove_on_shutdown_callback(const OnShutdownCallbackHandle & callback_handle);
        -:  255:
        -:  256:  using PreShutdownCallback = PreShutdownCallbackHandle::ShutdownCallbackType;
        -:  257:
        -:  258:  /// Add a pre_shutdown callback to be called before shutdown is called for this context.
        -:  259:  /**
        -:  260:   * These callbacks will be called in the order they are added.
        -:  261:   *
        -:  262:   * When shutdown occurs due to the signal handler, these callbacks are run
        -:  263:   * asynchronously in the dedicated signal handling thread.
        -:  264:   *
        -:  265:   * \param[in] callback the pre_shutdown callback to be registered
        -:  266:   * \return the created callback handle
        -:  267:   */
        -:  268:  RCLCPP_PUBLIC
        -:  269:  virtual
        -:  270:  PreShutdownCallbackHandle
        -:  271:  add_pre_shutdown_callback(PreShutdownCallback callback);
        -:  272:
        -:  273:  /// Remove an registered pre_shutdown callback.
        -:  274:  /**
        -:  275:   * \param[in] callback_handle the pre_shutdown callback handle to be removed.
        -:  276:   * \return true if the callback is found and removed, otherwise false.
        -:  277:   */
        -:  278:  RCLCPP_PUBLIC
        -:  279:  virtual
        -:  280:  bool
        -:  281:  remove_pre_shutdown_callback(const PreShutdownCallbackHandle & callback_handle);
        -:  282:
        -:  283:  /// Return the shutdown callbacks.
        -:  284:  /**
        -:  285:   * Returned callbacks are a copy of the registered callbacks.
        -:  286:   */
        -:  287:  RCLCPP_PUBLIC
        -:  288:  std::vector<OnShutdownCallback>
        -:  289:  get_on_shutdown_callbacks() const;
        -:  290:
        -:  291:  /// Return the pre-shutdown callbacks.
        -:  292:  /**
        -:  293:   * Returned callbacks are a copy of the registered callbacks.
        -:  294:   */
        -:  295:  RCLCPP_PUBLIC
        -:  296:  std::vector<PreShutdownCallback>
        -:  297:  get_pre_shutdown_callbacks() const;
        -:  298:
        -:  299:  /// Return the internal rcl context.
        -:  300:  RCLCPP_PUBLIC
        -:  301:  std::shared_ptr<rcl_context_t>
        -:  302:  get_rcl_context();
        -:  303:
        -:  304:  /// Sleep for a given period of time or until shutdown() is called.
        -:  305:  /**
        -:  306:   * This function can be interrupted early if:
        -:  307:   *
        -:  308:   *   - this context is shutdown()
        -:  309:   *   - this context is destructed (resulting in shutdown)
        -:  310:   *   - this context has shutdown_on_signal=true and SIGINT/SIGTERM occurs (resulting in shutdown)
        -:  311:   *   - interrupt_all_sleep_for() is called
        -:  312:   *
        -:  313:   * \param[in] nanoseconds A std::chrono::duration representing how long to sleep for.
        -:  314:   * \return true if the condition variable did not timeout, i.e. you were interrupted.
        -:  315:   */
        -:  316:  RCLCPP_PUBLIC
        -:  317:  bool
        -:  318:  sleep_for(const std::chrono::nanoseconds & nanoseconds);
        -:  319:
        -:  320:  /// Interrupt any blocking sleep_for calls, causing them to return immediately and return true.
        -:  321:  RCLCPP_PUBLIC
        -:  322:  virtual
        -:  323:  void
        -:  324:  interrupt_all_sleep_for();
        -:  325:
        -:  326:  /// Return a singleton instance for the SubContext type, constructing one if necessary.
        -:  327:  template<typename SubContext, typename ... Args>
        -:  328:  std::shared_ptr<SubContext>
function _ZN6rclcpp7Context15get_sub_contextINS_12experimental19IntraProcessManagerEJEEESt10shared_ptrIT_EDpOT0_ called 0 returned 0% blocks executed 0%
    #####:  329:  get_sub_context(Args && ... args)
        -:  330:  {
    #####:  331:    std::lock_guard<std::recursive_mutex> lock(sub_contexts_mutex_);
    %%%%%:  331-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  332:
    #####:  333:    std::type_index type_i(typeid(SubContext));
    %%%%%:  333-block  0
call    0 never executed
    #####:  334:    std::shared_ptr<SubContext> sub_context;
    #####:  335:    auto it = sub_contexts_.find(type_i);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  336:    if (it == sub_contexts_.end()) {
    %%%%%:  336-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  337:      // It doesn't exist yet, make it
    #####:  338:      sub_context = std::shared_ptr<SubContext>(
    %%%%%:  338-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  338-block  1
call    3 never executed
call    4 never executed
    #####:  339:        new SubContext(std::forward<Args>(args) ...),
    %%%%%:  339-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  339-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    $$$$$:  339-block  2
call    6 never executed
function _ZZN6rclcpp7Context15get_sub_contextINS_12experimental19IntraProcessManagerEJEEESt10shared_ptrIT_EDpOT0_ENKUlPS3_E_clESA_ called 0 returned 0% blocks executed 0%
    #####:  340:        [](SubContext * sub_context_ptr) {
    #####:  341:          delete sub_context_ptr;
    %%%%%:  341-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  341-block  1
call    2 never executed
        -:  342:        });
    #####:  343:      sub_contexts_[type_i] = sub_context;
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  343-block  0
call    3 never executed
        -:  344:    } else {
        -:  345:      // It exists, get it out and cast it.
    #####:  346:      sub_context = std::static_pointer_cast<SubContext>(it->second);
    %%%%%:  346-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  347:    }
    #####:  348:    return sub_context;
    %%%%%:  348-block  0
    %%%%%:  348-block  1
    #####:  349:  }
    %%%%%:  349-block  0
call    0 never executed
    $$$$$:  349-block  1
call    1 never executed
    $$$$$:  349-block  2
call    2 never executed
        -:  350:
        -:  351:protected:
        -:  352:  // Called by constructor and destructor to clean up by finalizing the
        -:  353:  // shutdown rcl context and preparing for a new init cycle.
        -:  354:  RCLCPP_PUBLIC
        -:  355:  virtual
        -:  356:  void
        -:  357:  clean_up();
        -:  358:
        -:  359:private:
        -:  360:  RCLCPP_DISABLE_COPY(Context)
        -:  361:
        -:  362:  // This mutex is recursive so that the destructor can ensure atomicity
        -:  363:  // between is_initialized and shutdown.
        -:  364:  mutable std::recursive_mutex init_mutex_;
        -:  365:  std::shared_ptr<rcl_context_t> rcl_context_;
        -:  366:  rclcpp::InitOptions init_options_;
        -:  367:  std::string shutdown_reason_;
        -:  368:
        -:  369:  // Keep shared ownership of the global logging mutex.
        -:  370:  std::shared_ptr<std::recursive_mutex> logging_mutex_;
        -:  371:
        -:  372:  std::unordered_map<std::type_index, std::shared_ptr<void>> sub_contexts_;
        -:  373:  // This mutex is recursive so that the constructor of a sub context may
        -:  374:  // attempt to acquire another sub context.
        -:  375:  std::recursive_mutex sub_contexts_mutex_;
        -:  376:
        -:  377:  std::unordered_set<std::shared_ptr<OnShutdownCallback>> on_shutdown_callbacks_;
        -:  378:  mutable std::mutex on_shutdown_callbacks_mutex_;
        -:  379:
        -:  380:  std::unordered_set<std::shared_ptr<PreShutdownCallback>> pre_shutdown_callbacks_;
        -:  381:  mutable std::mutex pre_shutdown_callbacks_mutex_;
        -:  382:
        -:  383:  /// Condition variable for timed sleep (see sleep_for).
        -:  384:  std::condition_variable interrupt_condition_variable_;
        -:  385:  /// Mutex for protecting the global condition variable.
        -:  386:  std::mutex interrupt_mutex_;
        -:  387:
        -:  388:  /// Keep shared ownership of global vector of weak contexts
        -:  389:  std::shared_ptr<WeakContextsWrapper> weak_contexts_;
        -:  390:
        -:  391:  enum class ShutdownType
        -:  392:  {
        -:  393:    pre_shutdown,
        -:  394:    on_shutdown
        -:  395:  };
        -:  396:
        -:  397:  using ShutdownCallback = ShutdownCallbackHandle::ShutdownCallbackType;
        -:  398:
        -:  399:  RCLCPP_LOCAL
        -:  400:  ShutdownCallbackHandle
        -:  401:  add_shutdown_callback(
        -:  402:    ShutdownType shutdown_type,
        -:  403:    ShutdownCallback callback);
        -:  404:
        -:  405:  RCLCPP_LOCAL
        -:  406:  bool
        -:  407:  remove_shutdown_callback(
        -:  408:    ShutdownType shutdown_type,
        -:  409:    const ShutdownCallbackHandle & callback_handle);
        -:  410:
        -:  411:  std::vector<rclcpp::Context::ShutdownCallback>
        -:  412:  get_shutdown_callback(ShutdownType shutdown_type) const;
        -:  413:};
        -:  414:
        -:  415:/// Return a copy of the list of context shared pointers.
        -:  416:/**
        -:  417: * This function is thread-safe.
        -:  418: */
        -:  419:RCLCPP_PUBLIC
        -:  420:std::vector<Context::SharedPtr>
        -:  421:get_contexts();
        -:  422:
        -:  423:}  // namespace rclcpp
        -:  424:
        -:  425:#endif  // RCLCPP__CONTEXT_HPP_
