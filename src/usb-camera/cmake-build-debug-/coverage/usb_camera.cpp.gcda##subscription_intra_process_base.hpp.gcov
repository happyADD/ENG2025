        -:    0:Source:/opt/ros/humble/include/rclcpp/rclcpp/experimental/subscription_intra_process_base.hpp
        -:    0:Graph:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcno
        -:    0:Data:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcda
        -:    0:Runs:1
        -:    1:// Copyright 2019 Open Source Robotics Foundation, Inc.
        -:    2://
        -:    3:// Licensed under the Apache License, Version 2.0 (the "License");
        -:    4:// you may not use this file except in compliance with the License.
        -:    5:// You may obtain a copy of the License at
        -:    6://
        -:    7://     http://www.apache.org/licenses/LICENSE-2.0
        -:    8://
        -:    9:// Unless required by applicable law or agreed to in writing, software
        -:   10:// distributed under the License is distributed on an "AS IS" BASIS,
        -:   11:// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12:// See the License for the specific language governing permissions and
        -:   13:// limitations under the License.
        -:   14:
        -:   15:#ifndef RCLCPP__EXPERIMENTAL__SUBSCRIPTION_INTRA_PROCESS_BASE_HPP_
        -:   16:#define RCLCPP__EXPERIMENTAL__SUBSCRIPTION_INTRA_PROCESS_BASE_HPP_
        -:   17:
        -:   18:#include <algorithm>
        -:   19:#include <memory>
        -:   20:#include <mutex>
        -:   21:#include <string>
        -:   22:
        -:   23:#include "rcl/wait.h"
        -:   24:#include "rmw/impl/cpp/demangle.hpp"
        -:   25:
        -:   26:#include "rclcpp/guard_condition.hpp"
        -:   27:#include "rclcpp/logging.hpp"
        -:   28:#include "rclcpp/qos.hpp"
        -:   29:#include "rclcpp/waitable.hpp"
        -:   30:
        -:   31:namespace rclcpp
        -:   32:{
        -:   33:namespace experimental
        -:   34:{
        -:   35:
        -:   36:class SubscriptionIntraProcessBase : public rclcpp::Waitable
        -:   37:{
        -:   38:public:
        -:   39:  RCLCPP_SMART_PTR_ALIASES_ONLY(SubscriptionIntraProcessBase)
        -:   40:
        -:   41:  enum class EntityType : std::size_t
        -:   42:  {
        -:   43:    Subscription,
        -:   44:  };
        -:   45:
        -:   46:  RCLCPP_PUBLIC
        -:   47:  SubscriptionIntraProcessBase(
        -:   48:    rclcpp::Context::SharedPtr context,
        -:   49:    const std::string & topic_name,
        -:   50:    const rclcpp::QoS & qos_profile)
        -:   51:  : gc_(context), topic_name_(topic_name), qos_profile_(qos_profile)
        -:   52:  {}
        -:   53:
        -:   54:  RCLCPP_PUBLIC
        -:   55:  virtual ~SubscriptionIntraProcessBase();
        -:   56:
        -:   57:  RCLCPP_PUBLIC
        -:   58:  size_t
        -:   59:  get_number_of_ready_guard_conditions() override {return 1;}
        -:   60:
        -:   61:  RCLCPP_PUBLIC
        -:   62:  void
        -:   63:  add_to_wait_set(rcl_wait_set_t * wait_set) override;
        -:   64:
        -:   65:  bool
        -:   66:  is_ready(rcl_wait_set_t * wait_set) override = 0;
        -:   67:
        -:   68:  std::shared_ptr<void>
        -:   69:  take_data() override = 0;
        -:   70:
        -:   71:  std::shared_ptr<void>
        -:   72:  take_data_by_entity_id(size_t id) override
        -:   73:  {
        -:   74:    (void)id;
        -:   75:    return take_data();
        -:   76:  }
        -:   77:
        -:   78:  void
        -:   79:  execute(std::shared_ptr<void> & data) override = 0;
        -:   80:
        -:   81:  virtual
        -:   82:  bool
        -:   83:  use_take_shared_method() const = 0;
        -:   84:
        -:   85:  RCLCPP_PUBLIC
        -:   86:  const char *
        -:   87:  get_topic_name() const;
        -:   88:
        -:   89:  RCLCPP_PUBLIC
        -:   90:  QoS
        -:   91:  get_actual_qos() const;
        -:   92:
        -:   93:  /// Set a callback to be called when each new message arrives.
        -:   94:  /**
        -:   95:   * The callback receives a size_t which is the number of messages received
        -:   96:   * since the last time this callback was called.
        -:   97:   * Normally this is 1, but can be > 1 if messages were received before any
        -:   98:   * callback was set.
        -:   99:   *
        -:  100:   * The callback also receives an int identifier argument.
        -:  101:   * This is needed because a Waitable may be composed of several distinct entities,
        -:  102:   * such as subscriptions, services, etc.
        -:  103:   * The application should provide a generic callback function that will be then
        -:  104:   * forwarded by the waitable to all of its entities.
        -:  105:   * Before forwarding, a different value for the identifier argument will be
        -:  106:   * bound to the function.
        -:  107:   * This implies that the provided callback can use the identifier to behave
        -:  108:   * differently depending on which entity triggered the waitable to become ready.
        -:  109:   *
        -:  110:   * Calling it again will clear any previously set callback.
        -:  111:   *
        -:  112:   * An exception will be thrown if the callback is not callable.
        -:  113:   *
        -:  114:   * This function is thread-safe.
        -:  115:   *
        -:  116:   * If you want more information available in the callback, like the subscription
        -:  117:   * or other information, you may use a lambda with captures or std::bind.
        -:  118:   *
        -:  119:   * \param[in] callback functor to be called when a new message is received.
        -:  120:   */
        -:  121:  void
        -:  122:  set_on_ready_callback(std::function<void(size_t, int)> callback) override
        -:  123:  {
        -:  124:    if (!callback) {
        -:  125:      throw std::invalid_argument(
        -:  126:              "The callback passed to set_on_ready_callback "
        -:  127:              "is not callable.");
        -:  128:    }
        -:  129:
        -:  130:    // Note: we bind the int identifier argument to this waitable's entity types
        -:  131:    auto new_callback =
        -:  132:      [callback, this](size_t number_of_events) {
        -:  133:        try {
        -:  134:          callback(number_of_events, static_cast<int>(EntityType::Subscription));
        -:  135:        } catch (const std::exception & exception) {
        -:  136:          RCLCPP_ERROR_STREAM(
        -:  137:            // TODO(wjwwood): get this class access to the node logger it is associated with
        -:  138:            rclcpp::get_logger("rclcpp"),
        -:  139:            "rclcpp::SubscriptionIntraProcessBase@" << this <<
        -:  140:              " caught " << rmw::impl::cpp::demangle(exception) <<
        -:  141:              " exception in user-provided callback for the 'on ready' callback: " <<
        -:  142:              exception.what());
        -:  143:        } catch (...) {
        -:  144:          RCLCPP_ERROR_STREAM(
        -:  145:            rclcpp::get_logger("rclcpp"),
        -:  146:            "rclcpp::SubscriptionIntraProcessBase@" << this <<
        -:  147:              " caught unhandled exception in user-provided callback " <<
        -:  148:              "for the 'on ready' callback");
        -:  149:        }
        -:  150:      };
        -:  151:
        -:  152:    std::lock_guard<std::recursive_mutex> lock(callback_mutex_);
        -:  153:    on_new_message_callback_ = new_callback;
        -:  154:
        -:  155:    if (unread_count_ > 0) {
        -:  156:      if (qos_profile_.history() == HistoryPolicy::KeepAll) {
        -:  157:        on_new_message_callback_(unread_count_);
        -:  158:      } else {
        -:  159:        // Use qos profile depth as upper bound for unread_count_
        -:  160:        on_new_message_callback_(std::min(unread_count_, qos_profile_.depth()));
        -:  161:      }
        -:  162:      unread_count_ = 0;
        -:  163:    }
        -:  164:  }
        -:  165:
        -:  166:  /// Unset the callback registered for new messages, if any.
        -:  167:  void
        -:  168:  clear_on_ready_callback() override
        -:  169:  {
        -:  170:    std::lock_guard<std::recursive_mutex> lock(callback_mutex_);
        -:  171:    on_new_message_callback_ = nullptr;
        -:  172:  }
        -:  173:
        -:  174:protected:
        -:  175:  std::recursive_mutex callback_mutex_;
        -:  176:  std::function<void(size_t)> on_new_message_callback_ {nullptr};
        -:  177:  size_t unread_count_{0};
        -:  178:  rclcpp::GuardCondition gc_;
        -:  179:
        -:  180:  virtual void
        -:  181:  trigger_guard_condition() = 0;
        -:  182:
        -:  183:  void
function _ZN6rclcpp12experimental28SubscriptionIntraProcessBase21invoke_on_new_messageEv called 0 returned 0% blocks executed 0%
    #####:  184:  invoke_on_new_message()
        -:  185:  {
    #####:  186:    std::lock_guard<std::recursive_mutex> lock(this->callback_mutex_);
    %%%%%:  186-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  187:    if (this->on_new_message_callback_) {
    %%%%%:  187-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  188:      this->on_new_message_callback_(1);
    %%%%%:  188-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  189:    } else {
    #####:  190:      this->unread_count_++;
    %%%%%:  190-block  0
        -:  191:    }
    #####:  192:  }
    %%%%%:  192-block  0
call    0 never executed
    $$$$$:  192-block  1
call    1 never executed
        -:  193:
        -:  194:private:
        -:  195:  std::string topic_name_;
        -:  196:  QoS qos_profile_;
        -:  197:};
        -:  198:
        -:  199:}  // namespace experimental
        -:  200:}  // namespace rclcpp
        -:  201:
        -:  202:#endif  // RCLCPP__EXPERIMENTAL__SUBSCRIPTION_INTRA_PROCESS_BASE_HPP_
