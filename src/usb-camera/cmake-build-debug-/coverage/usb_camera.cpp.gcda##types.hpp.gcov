        -:    0:Source:/usr/local/include/opencv4/opencv2/core/types.hpp
        -:    0:Graph:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcno
        -:    0:Data:/home/dcy/ENG/ENG2025/src/usb-camera/cmake-build-debug-/CMakeFiles/usb_camera.dir/src/usb_camera.cpp.gcda
        -:    0:Runs:1
        -:    1:/*M///////////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3://  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
        -:    4://
        -:    5://  By downloading, copying, installing or using the software you agree to this license.
        -:    6://  If you do not agree to this license, do not download, install,
        -:    7://  copy or use the software.
        -:    8://
        -:    9://
        -:   10://                          License Agreement
        -:   11://                For Open Source Computer Vision Library
        -:   12://
        -:   13:// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
        -:   14:// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
        -:   15:// Copyright (C) 2013, OpenCV Foundation, all rights reserved.
        -:   16:// Third party copyrights are property of their respective owners.
        -:   17://
        -:   18:// Redistribution and use in source and binary forms, with or without modification,
        -:   19:// are permitted provided that the following conditions are met:
        -:   20://
        -:   21://   * Redistribution's of source code must retain the above copyright notice,
        -:   22://     this list of conditions and the following disclaimer.
        -:   23://
        -:   24://   * Redistribution's in binary form must reproduce the above copyright notice,
        -:   25://     this list of conditions and the following disclaimer in the documentation
        -:   26://     and/or other materials provided with the distribution.
        -:   27://
        -:   28://   * The name of the copyright holders may not be used to endorse or promote products
        -:   29://     derived from this software without specific prior written permission.
        -:   30://
        -:   31:// This software is provided by the copyright holders and contributors "as is" and
        -:   32:// any express or implied warranties, including, but not limited to, the implied
        -:   33:// warranties of merchantability and fitness for a particular purpose are disclaimed.
        -:   34:// In no event shall the Intel Corporation or contributors be liable for any direct,
        -:   35:// indirect, incidental, special, exemplary, or consequential damages
        -:   36:// (including, but not limited to, procurement of substitute goods or services;
        -:   37:// loss of use, data, or profits; or business interruption) however caused
        -:   38:// and on any theory of liability, whether in contract, strict liability,
        -:   39:// or tort (including negligence or otherwise) arising in any way out of
        -:   40:// the use of this software, even if advised of the possibility of such damage.
        -:   41://
        -:   42://M*/
        -:   43:
        -:   44:#ifndef OPENCV_CORE_TYPES_HPP
        -:   45:#define OPENCV_CORE_TYPES_HPP
        -:   46:
        -:   47:#ifndef __cplusplus
        -:   48:#  error types.hpp header must be compiled as C++
        -:   49:#endif
        -:   50:
        -:   51:#include <climits>
        -:   52:#include <cfloat>
        -:   53:#include <vector>
        -:   54:#include <limits>
        -:   55:
        -:   56:#include "opencv2/core/cvdef.h"
        -:   57:#include "opencv2/core/cvstd.hpp"
        -:   58:#include "opencv2/core/matx.hpp"
        -:   59:
        -:   60:#ifdef _MSC_VER
        -:   61:#pragma warning(push)
        -:   62:#pragma warning(disable: 4459)  // declaration of '...' hides global declaration
        -:   63:#endif
        -:   64:
        -:   65:namespace cv
        -:   66:{
        -:   67:
        -:   68://! @addtogroup core_basic
        -:   69://! @{
        -:   70:
        -:   71://////////////////////////////// Complex //////////////////////////////
        -:   72:
        -:   73:/** @brief  A complex number class.
        -:   74:
        -:   75:  The template class is similar and compatible with std::complex, however it provides slightly
        -:   76:  more convenient access to the real and imaginary parts using through the simple field access, as opposite
        -:   77:  to std::complex::real() and std::complex::imag().
        -:   78:*/
        -:   79:template<typename _Tp> class Complex
        -:   80:{
        -:   81:public:
        -:   82:
        -:   83:    //! default constructor
        -:   84:    Complex();
        -:   85:    Complex( _Tp _re, _Tp _im = 0 );
        -:   86:
        -:   87:    //! conversion to another data type
        -:   88:    template<typename T2> operator Complex<T2>() const;
        -:   89:    //! conjugation
        -:   90:    Complex conj() const;
        -:   91:
        -:   92:    _Tp re, im; ///< the real and the imaginary parts
        -:   93:};
        -:   94:
        -:   95:typedef Complex<float> Complexf;
        -:   96:typedef Complex<double> Complexd;
        -:   97:
        -:   98:template<typename _Tp> class DataType< Complex<_Tp> >
        -:   99:{
        -:  100:public:
        -:  101:    typedef Complex<_Tp> value_type;
        -:  102:    typedef value_type   work_type;
        -:  103:    typedef _Tp          channel_type;
        -:  104:
        -:  105:    enum { generic_type = 0,
        -:  106:           channels     = 2,
        -:  107:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  108:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  109:           ,depth        = DataType<channel_type>::depth
        -:  110:           ,type         = CV_MAKETYPE(depth, channels)
        -:  111:#endif
        -:  112:    };
        -:  113:
        -:  114:    typedef Vec<channel_type, channels> vec_type;
        -:  115:};
        -:  116:
        -:  117:namespace traits {
        -:  118:template<typename _Tp>
        -:  119:struct Depth< Complex<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  120:template<typename _Tp>
        -:  121:struct Type< Complex<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  122:} // namespace
        -:  123:
        -:  124:
        -:  125://////////////////////////////// Point_ ////////////////////////////////
        -:  126:
        -:  127:/** @brief Template class for 2D points specified by its coordinates `x` and `y`.
        -:  128:
        -:  129:An instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is
        -:  130:also a cast operator to convert point coordinates to the specified type. The conversion from
        -:  131:floating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion
        -:  132:uses this operation for each of the coordinates. Besides the class members listed in the
        -:  133:declaration above, the following operations on points are implemented:
        -:  134:@code
        -:  135:    pt1 = pt2 + pt3;
        -:  136:    pt1 = pt2 - pt3;
        -:  137:    pt1 = pt2 * a;
        -:  138:    pt1 = a * pt2;
        -:  139:    pt1 = pt2 / a;
        -:  140:    pt1 += pt2;
        -:  141:    pt1 -= pt2;
        -:  142:    pt1 *= a;
        -:  143:    pt1 /= a;
        -:  144:    double value = norm(pt); // L2 norm
        -:  145:    pt1 == pt2;
        -:  146:    pt1 != pt2;
        -:  147:@endcode
        -:  148:For your convenience, the following type aliases are defined:
        -:  149:@code
        -:  150:    typedef Point_<int> Point2i;
        -:  151:    typedef Point2i Point;
        -:  152:    typedef Point_<float> Point2f;
        -:  153:    typedef Point_<double> Point2d;
        -:  154:@endcode
        -:  155:Example:
        -:  156:@code
        -:  157:    Point2f a(0.3f, 0.f), b(0.f, 0.4f);
        -:  158:    Point pt = (a + b)*10.f;
        -:  159:    cout << pt.x << ", " << pt.y << endl;
        -:  160:@endcode
        -:  161:*/
        -:  162:template<typename _Tp> class Point_
        -:  163:{
        -:  164:public:
        -:  165:    typedef _Tp value_type;
        -:  166:
        -:  167:    //! default constructor
        -:  168:    Point_();
        -:  169:    Point_(_Tp _x, _Tp _y);
        -:  170:#if (defined(__GNUC__) && __GNUC__ < 5) && !defined(__clang__)  // GCC 4.x bug. Details: https://github.com/opencv/opencv/pull/20837
        -:  171:    Point_(const Point_& pt);
        -:  172:    Point_(Point_&& pt) CV_NOEXCEPT = default;
        -:  173:#elif OPENCV_ABI_COMPATIBILITY < 500
        -:  174:    Point_(const Point_& pt) = default;
        -:  175:    Point_(Point_&& pt) CV_NOEXCEPT = default;
        -:  176:#endif
        -:  177:    Point_(const Size_<_Tp>& sz);
        -:  178:    Point_(const Vec<_Tp, 2>& v);
        -:  179:
        -:  180:#if (defined(__GNUC__) && __GNUC__ < 5) && !defined(__clang__)  // GCC 4.x bug. Details: https://github.com/opencv/opencv/pull/20837
        -:  181:    Point_& operator = (const Point_& pt);
        -:  182:    Point_& operator = (Point_&& pt) CV_NOEXCEPT = default;
        -:  183:#elif OPENCV_ABI_COMPATIBILITY < 500
        -:  184:    Point_& operator = (const Point_& pt) = default;
        -:  185:    Point_& operator = (Point_&& pt) CV_NOEXCEPT = default;
        -:  186:#endif
        -:  187:    //! conversion to another data type
        -:  188:    template<typename _Tp2> operator Point_<_Tp2>() const;
        -:  189:
        -:  190:    //! conversion to the old-style C structures
        -:  191:    operator Vec<_Tp, 2>() const;
        -:  192:
        -:  193:    //! dot product
        -:  194:    _Tp dot(const Point_& pt) const;
        -:  195:    //! dot product computed in double-precision arithmetics
        -:  196:    double ddot(const Point_& pt) const;
        -:  197:    //! cross-product
        -:  198:    double cross(const Point_& pt) const;
        -:  199:    //! checks whether the point is inside the specified rectangle
        -:  200:    bool inside(const Rect_<_Tp>& r) const;
        -:  201:    _Tp x; //!< x coordinate of the point
        -:  202:    _Tp y; //!< y coordinate of the point
        -:  203:};
        -:  204:
        -:  205:typedef Point_<int> Point2i;
        -:  206:typedef Point_<int64> Point2l;
        -:  207:typedef Point_<float> Point2f;
        -:  208:typedef Point_<double> Point2d;
        -:  209:typedef Point2i Point;
        -:  210:
        -:  211:template<typename _Tp> class DataType< Point_<_Tp> >
        -:  212:{
        -:  213:public:
        -:  214:    typedef Point_<_Tp>                               value_type;
        -:  215:    typedef Point_<typename DataType<_Tp>::work_type> work_type;
        -:  216:    typedef _Tp                                       channel_type;
        -:  217:
        -:  218:    enum { generic_type = 0,
        -:  219:           channels     = 2,
        -:  220:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  221:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  222:           ,depth        = DataType<channel_type>::depth
        -:  223:           ,type         = CV_MAKETYPE(depth, channels)
        -:  224:#endif
        -:  225:         };
        -:  226:
        -:  227:    typedef Vec<channel_type, channels> vec_type;
        -:  228:};
        -:  229:
        -:  230:namespace traits {
        -:  231:template<typename _Tp>
        -:  232:struct Depth< Point_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  233:template<typename _Tp>
        -:  234:struct Type< Point_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  235:} // namespace
        -:  236:
        -:  237:
        -:  238://////////////////////////////// Point3_ ////////////////////////////////
        -:  239:
        -:  240:/** @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.
        -:  241:
        -:  242:An instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to
        -:  243:Point_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and
        -:  244:comparison operations are also supported.
        -:  245:
        -:  246:The following Point3_\<\> aliases are available:
        -:  247:@code
        -:  248:    typedef Point3_<int> Point3i;
        -:  249:    typedef Point3_<float> Point3f;
        -:  250:    typedef Point3_<double> Point3d;
        -:  251:@endcode
        -:  252:@see cv::Point3i, cv::Point3f and cv::Point3d
        -:  253:*/
        -:  254:template<typename _Tp> class Point3_
        -:  255:{
        -:  256:public:
        -:  257:    typedef _Tp value_type;
        -:  258:
        -:  259:    //! default constructor
        -:  260:    Point3_();
        -:  261:    Point3_(_Tp _x, _Tp _y, _Tp _z);
        -:  262:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  263:    Point3_(const Point3_& pt) = default;
        -:  264:    Point3_(Point3_&& pt) CV_NOEXCEPT = default;
        -:  265:#endif
        -:  266:    explicit Point3_(const Point_<_Tp>& pt);
        -:  267:    Point3_(const Vec<_Tp, 3>& v);
        -:  268:
        -:  269:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  270:    Point3_& operator = (const Point3_& pt) = default;
        -:  271:    Point3_& operator = (Point3_&& pt) CV_NOEXCEPT = default;
        -:  272:#endif
        -:  273:    //! conversion to another data type
        -:  274:    template<typename _Tp2> operator Point3_<_Tp2>() const;
        -:  275:    //! conversion to cv::Vec<>
        -:  276:    operator Vec<_Tp, 3>() const;
        -:  277:
        -:  278:    //! dot product
        -:  279:    _Tp dot(const Point3_& pt) const;
        -:  280:    //! dot product computed in double-precision arithmetics
        -:  281:    double ddot(const Point3_& pt) const;
        -:  282:    //! cross product of the 2 3D points
        -:  283:    Point3_ cross(const Point3_& pt) const;
        -:  284:    _Tp x; //!< x coordinate of the 3D point
        -:  285:    _Tp y; //!< y coordinate of the 3D point
        -:  286:    _Tp z; //!< z coordinate of the 3D point
        -:  287:};
        -:  288:
        -:  289:typedef Point3_<int> Point3i;
        -:  290:typedef Point3_<float> Point3f;
        -:  291:typedef Point3_<double> Point3d;
        -:  292:
        -:  293:template<typename _Tp> class DataType< Point3_<_Tp> >
        -:  294:{
        -:  295:public:
        -:  296:    typedef Point3_<_Tp>                               value_type;
        -:  297:    typedef Point3_<typename DataType<_Tp>::work_type> work_type;
        -:  298:    typedef _Tp                                        channel_type;
        -:  299:
        -:  300:    enum { generic_type = 0,
        -:  301:           channels     = 3,
        -:  302:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  303:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  304:           ,depth        = DataType<channel_type>::depth
        -:  305:           ,type         = CV_MAKETYPE(depth, channels)
        -:  306:#endif
        -:  307:         };
        -:  308:
        -:  309:    typedef Vec<channel_type, channels> vec_type;
        -:  310:};
        -:  311:
        -:  312:namespace traits {
        -:  313:template<typename _Tp>
        -:  314:struct Depth< Point3_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  315:template<typename _Tp>
        -:  316:struct Type< Point3_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 3) }; };
        -:  317:} // namespace
        -:  318:
        -:  319://////////////////////////////// Size_ ////////////////////////////////
        -:  320:
        -:  321:/** @brief Template class for specifying the size of an image or rectangle.
        -:  322:
        -:  323:The class includes two members called width and height. The structure can be converted to and from
        -:  324:the old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison
        -:  325:operations as for Point_ is available.
        -:  326:
        -:  327:OpenCV defines the following Size_\<\> aliases:
        -:  328:@code
        -:  329:    typedef Size_<int> Size2i;
        -:  330:    typedef Size2i Size;
        -:  331:    typedef Size_<float> Size2f;
        -:  332:@endcode
        -:  333:*/
        -:  334:template<typename _Tp> class Size_
        -:  335:{
        -:  336:public:
        -:  337:    typedef _Tp value_type;
        -:  338:
        -:  339:    //! default constructor
        -:  340:    Size_();
        -:  341:    Size_(_Tp _width, _Tp _height);
        -:  342:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  343:    Size_(const Size_& sz) = default;
        -:  344:    Size_(Size_&& sz) CV_NOEXCEPT = default;
        -:  345:#endif
        -:  346:    Size_(const Point_<_Tp>& pt);
        -:  347:
        -:  348:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  349:    Size_& operator = (const Size_& sz) = default;
        -:  350:    Size_& operator = (Size_&& sz) CV_NOEXCEPT = default;
        -:  351:#endif
        -:  352:    //! the area (width*height)
        -:  353:    _Tp area() const;
        -:  354:    //! aspect ratio (width/height)
        -:  355:    double aspectRatio() const;
        -:  356:    //! true if empty
        -:  357:    bool empty() const;
        -:  358:
        -:  359:    //! conversion of another data type.
        -:  360:    template<typename _Tp2> operator Size_<_Tp2>() const;
        -:  361:
        -:  362:    _Tp width; //!< the width
        -:  363:    _Tp height; //!< the height
        -:  364:};
        -:  365:
        -:  366:typedef Size_<int> Size2i;
        -:  367:typedef Size_<int64> Size2l;
        -:  368:typedef Size_<float> Size2f;
        -:  369:typedef Size_<double> Size2d;
        -:  370:typedef Size2i Size;
        -:  371:
        -:  372:template<typename _Tp> class DataType< Size_<_Tp> >
        -:  373:{
        -:  374:public:
        -:  375:    typedef Size_<_Tp>                               value_type;
        -:  376:    typedef Size_<typename DataType<_Tp>::work_type> work_type;
        -:  377:    typedef _Tp                                      channel_type;
        -:  378:
        -:  379:    enum { generic_type = 0,
        -:  380:           channels     = 2,
        -:  381:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  382:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  383:           ,depth        = DataType<channel_type>::depth
        -:  384:           ,type         = CV_MAKETYPE(depth, channels)
        -:  385:#endif
        -:  386:         };
        -:  387:
        -:  388:    typedef Vec<channel_type, channels> vec_type;
        -:  389:};
        -:  390:
        -:  391:namespace traits {
        -:  392:template<typename _Tp>
        -:  393:struct Depth< Size_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  394:template<typename _Tp>
        -:  395:struct Type< Size_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };
        -:  396:} // namespace
        -:  397:
        -:  398://////////////////////////////// Rect_ ////////////////////////////////
        -:  399:
        -:  400:/** @brief Template class for 2D rectangles
        -:  401:
        -:  402:described by the following parameters:
        -:  403:-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y
        -:  404:    in OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.
        -:  405:-   Rectangle width and height.
        -:  406:
        -:  407:OpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the
        -:  408:right and bottom boundaries are not. For example, the method Rect_::contains returns true if
        -:  409:
        -:  410:\f[x  \leq pt.x < x+width,
        -:  411:      y  \leq pt.y < y+height\f]
        -:  412:
        -:  413:Virtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\<int\> ) is
        -:  414:implemented as:
        -:  415:@code
        -:  416:    for(int y = roi.y; y < roi.y + roi.height; y++)
        -:  417:        for(int x = roi.x; x < roi.x + roi.width; x++)
        -:  418:        {
        -:  419:            // ...
        -:  420:        }
        -:  421:@endcode
        -:  422:In addition to the class members, the following operations on rectangles are implemented:
        -:  423:-   \f$\texttt{rect} = \texttt{rect} \pm \texttt{point}\f$ (shifting a rectangle by a certain offset)
        -:  424:-   \f$\texttt{rect} = \texttt{rect} \pm \texttt{size}\f$ (expanding or shrinking a rectangle by a
        -:  425:    certain amount)
        -:  426:-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)
        -:  427:-   rect = rect1 & rect2 (rectangle intersection)
        -:  428:-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )
        -:  429:-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
        -:  430:-   rect == rect1, rect != rect1 (rectangle comparison)
        -:  431:
        -:  432:This is an example how the partial ordering on rectangles can be established (rect1 \f$\subseteq\f$
        -:  433:rect2):
        -:  434:@code
        -:  435:    template<typename _Tp> inline bool
        -:  436:    operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
        -:  437:    {
        -:  438:        return (r1 & r2) == r1;
        -:  439:    }
        -:  440:@endcode
        -:  441:For your convenience, the Rect_\<\> alias is available: cv::Rect
        -:  442:*/
        -:  443:template<typename _Tp> class Rect_
        -:  444:{
        -:  445:public:
        -:  446:    typedef _Tp value_type;
        -:  447:
        -:  448:    //! default constructor
        -:  449:    Rect_();
        -:  450:    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
        -:  451:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  452:    Rect_(const Rect_& r) = default;
        -:  453:    Rect_(Rect_&& r) CV_NOEXCEPT = default;
        -:  454:#endif
        -:  455:    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
        -:  456:    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);
        -:  457:
        -:  458:#if OPENCV_ABI_COMPATIBILITY < 500
        -:  459:    Rect_& operator = (const Rect_& r) = default;
        -:  460:    Rect_& operator = (Rect_&& r) CV_NOEXCEPT = default;
        -:  461:#endif
        -:  462:    //! the top-left corner
        -:  463:    Point_<_Tp> tl() const;
        -:  464:    //! the bottom-right corner
        -:  465:    Point_<_Tp> br() const;
        -:  466:
        -:  467:    //! size (width, height) of the rectangle
        -:  468:    Size_<_Tp> size() const;
        -:  469:    //! area (width*height) of the rectangle
        -:  470:    _Tp area() const;
        -:  471:    //! true if empty
        -:  472:    bool empty() const;
        -:  473:
        -:  474:    //! conversion to another data type
        -:  475:    template<typename _Tp2> operator Rect_<_Tp2>() const;
        -:  476:
        -:  477:    //! checks whether the rectangle contains the point
        -:  478:    bool contains(const Point_<_Tp>& pt) const;
        -:  479:
        -:  480:    _Tp x; //!< x coordinate of the top-left corner
        -:  481:    _Tp y; //!< y coordinate of the top-left corner
        -:  482:    _Tp width; //!< width of the rectangle
        -:  483:    _Tp height; //!< height of the rectangle
        -:  484:};
        -:  485:
        -:  486:typedef Rect_<int> Rect2i;
        -:  487:typedef Rect_<float> Rect2f;
        -:  488:typedef Rect_<double> Rect2d;
        -:  489:typedef Rect2i Rect;
        -:  490:
        -:  491:template<typename _Tp> class DataType< Rect_<_Tp> >
        -:  492:{
        -:  493:public:
        -:  494:    typedef Rect_<_Tp>                               value_type;
        -:  495:    typedef Rect_<typename DataType<_Tp>::work_type> work_type;
        -:  496:    typedef _Tp                                      channel_type;
        -:  497:
        -:  498:    enum { generic_type = 0,
        -:  499:           channels     = 4,
        -:  500:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  501:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  502:           ,depth        = DataType<channel_type>::depth
        -:  503:           ,type         = CV_MAKETYPE(depth, channels)
        -:  504:#endif
        -:  505:         };
        -:  506:
        -:  507:    typedef Vec<channel_type, channels> vec_type;
        -:  508:};
        -:  509:
        -:  510:namespace traits {
        -:  511:template<typename _Tp>
        -:  512:struct Depth< Rect_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  513:template<typename _Tp>
        -:  514:struct Type< Rect_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };
        -:  515:} // namespace
        -:  516:
        -:  517:///////////////////////////// RotatedRect /////////////////////////////
        -:  518:
        -:  519:/** @brief The class represents rotated (i.e. not up-right) rectangles on a plane.
        -:  520:
        -:  521:Each rectangle is specified by the center point (mass center), length of each side (represented by
        -:  522:#Size2f structure) and the rotation angle in degrees.
        -:  523:
        -:  524:The sample below demonstrates how to use RotatedRect:
        -:  525:@snippet snippets/core_various.cpp RotatedRect_demo
        -:  526:![image](pics/rotatedrect.png)
        -:  527:
        -:  528:@sa CamShift, fitEllipse, minAreaRect, CvBox2D
        -:  529:*/
        -:  530:class CV_EXPORTS_W_SIMPLE RotatedRect
        -:  531:{
        -:  532:public:
        -:  533:    //! default constructor
        -:  534:    CV_WRAP RotatedRect();
        -:  535:    /** full constructor
        -:  536:    @param center The rectangle mass center.
        -:  537:    @param size Width and height of the rectangle.
        -:  538:    @param angle The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,
        -:  539:    the rectangle becomes an up-right rectangle.
        -:  540:    */
        -:  541:    CV_WRAP RotatedRect(const Point2f& center, const Size2f& size, float angle);
        -:  542:    /**
        -:  543:    Any 3 end points of the RotatedRect. They must be given in order (either clockwise or
        -:  544:    anticlockwise).
        -:  545:     */
        -:  546:    CV_WRAP RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3);
        -:  547:
        -:  548:    /** returns 4 vertices of the rotated rectangle
        -:  549:    @param pts The points array for storing rectangle vertices. The order is _bottomLeft_, _topLeft_, topRight, bottomRight.
        -:  550:    @note _Bottom_, _Top_, _Left_ and _Right_ sides refer to the original rectangle (angle is 0),
        -:  551:    so after 180 degree rotation _bottomLeft_ point will be located at the top right corner of the
        -:  552:    rectangle.
        -:  553:    */
        -:  554:    void points(Point2f pts[]) const;
        -:  555:
        -:  556:    CV_WRAP void points(CV_OUT std::vector<Point2f>& pts) const;
        -:  557:
        -:  558:    //! returns the minimal up-right integer rectangle containing the rotated rectangle
        -:  559:    CV_WRAP Rect boundingRect() const;
        -:  560:    //! returns the minimal (exact) floating point rectangle containing the rotated rectangle, not intended for use with images
        -:  561:    CV_WRAP Rect2f boundingRect2f() const;
        -:  562:    //! returns the rectangle mass center
        -:  563:    CV_PROP_RW Point2f center;
        -:  564:    //! returns width and height of the rectangle
        -:  565:    CV_PROP_RW Size2f size;
        -:  566:    //! returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.
        -:  567:    CV_PROP_RW float angle;
        -:  568:};
        -:  569:
        -:  570:template<> class DataType< RotatedRect >
        -:  571:{
        -:  572:public:
        -:  573:    typedef RotatedRect  value_type;
        -:  574:    typedef value_type   work_type;
        -:  575:    typedef float        channel_type;
        -:  576:
        -:  577:    enum { generic_type = 0,
        -:  578:           channels     = (int)sizeof(value_type)/sizeof(channel_type), // 5
        -:  579:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  580:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  581:           ,depth        = DataType<channel_type>::depth
        -:  582:           ,type         = CV_MAKETYPE(depth, channels)
        -:  583:#endif
        -:  584:         };
        -:  585:
        -:  586:    typedef Vec<channel_type, channels> vec_type;
        -:  587:};
        -:  588:
        -:  589:namespace traits {
        -:  590:template<>
        -:  591:struct Depth< RotatedRect > { enum { value = Depth<float>::value }; };
        -:  592:template<>
        -:  593:struct Type< RotatedRect > { enum { value = CV_MAKETYPE(Depth<float>::value, (int)sizeof(RotatedRect)/sizeof(float)) }; };
        -:  594:} // namespace
        -:  595:
        -:  596:
        -:  597://////////////////////////////// Range /////////////////////////////////
        -:  598:
        -:  599:/** @brief Template class specifying a continuous subsequence (slice) of a sequence.
        -:  600:
        -:  601:The class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.
        -:  602:Range(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an
        -:  603:inclusive left boundary of the range and end is an exclusive right boundary of the range. Such a
        -:  604:half-opened interval is usually denoted as \f$[start,end)\f$ .
        -:  605:
        -:  606:The static method Range::all() returns a special variable that means "the whole sequence" or "the
        -:  607:whole range", just like " : " in Matlab or " ... " in Python. All the methods and functions in
        -:  608:OpenCV that take Range support this special Range::all() value. But, of course, in case of your own
        -:  609:custom processing, you will probably have to check and handle it explicitly:
        -:  610:@code
        -:  611:    void my_function(..., const Range& r, ....)
        -:  612:    {
        -:  613:        if(r == Range::all()) {
        -:  614:            // process all the data
        -:  615:        }
        -:  616:        else {
        -:  617:            // process [r.start, r.end)
        -:  618:        }
        -:  619:    }
        -:  620:@endcode
        -:  621:*/
        -:  622:class CV_EXPORTS Range
        -:  623:{
        -:  624:public:
        -:  625:    Range();
        -:  626:    Range(int _start, int _end);
        -:  627:    int size() const;
        -:  628:    bool empty() const;
        -:  629:    static Range all();
        -:  630:
        -:  631:    int start, end;
        -:  632:};
        -:  633:
        -:  634:template<> class DataType<Range>
        -:  635:{
        -:  636:public:
        -:  637:    typedef Range      value_type;
        -:  638:    typedef value_type work_type;
        -:  639:    typedef int        channel_type;
        -:  640:
        -:  641:    enum { generic_type = 0,
        -:  642:           channels     = 2,
        -:  643:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  644:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  645:           ,depth        = DataType<channel_type>::depth
        -:  646:           ,type         = CV_MAKETYPE(depth, channels)
        -:  647:#endif
        -:  648:         };
        -:  649:
        -:  650:    typedef Vec<channel_type, channels> vec_type;
        -:  651:};
        -:  652:
        -:  653:namespace traits {
        -:  654:template<>
        -:  655:struct Depth< Range > { enum { value = Depth<int>::value }; };
        -:  656:template<>
        -:  657:struct Type< Range > { enum { value = CV_MAKETYPE(Depth<int>::value, 2) }; };
        -:  658:} // namespace
        -:  659:
        -:  660:
        -:  661://////////////////////////////// Scalar_ ///////////////////////////////
        -:  662:
        -:  663:/** @brief Template class for a 4-element vector derived from Vec.
        -:  664:
        -:  665:Being derived from Vec\<_Tp, 4\> , Scalar\_ and Scalar can be used just as typical 4-element
        -:  666:vectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in
        -:  667:OpenCV to pass pixel values.
        -:  668:*/
        -:  669:template<typename _Tp> class Scalar_ : public Vec<_Tp, 4>
        -:  670:{
        -:  671:public:
        -:  672:    //! default constructor
        -:  673:    Scalar_();
        -:  674:    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
        -:  675:    Scalar_(_Tp v0);
        -:  676:
        -:  677:    Scalar_(const Scalar_& s);
        -:  678:    Scalar_(Scalar_&& s) CV_NOEXCEPT;
        -:  679:
        -:  680:    Scalar_& operator=(const Scalar_& s);
        -:  681:    Scalar_& operator=(Scalar_&& s) CV_NOEXCEPT;
        -:  682:
        -:  683:    template<typename _Tp2, int cn>
        -:  684:    Scalar_(const Vec<_Tp2, cn>& v);
        -:  685:
        -:  686:    //! returns a scalar with all elements set to v0
        -:  687:    static Scalar_<_Tp> all(_Tp v0);
        -:  688:
        -:  689:    //! conversion to another data type
        -:  690:    template<typename T2> operator Scalar_<T2>() const;
        -:  691:
        -:  692:    //! per-element product
        -:  693:    Scalar_<_Tp> mul(const Scalar_<_Tp>& a, double scale=1 ) const;
        -:  694:
        -:  695:    //! returns (v0, -v1, -v2, -v3)
        -:  696:    Scalar_<_Tp> conj() const;
        -:  697:
        -:  698:    //! returns true iff v1 == v2 == v3 == 0
        -:  699:    bool isReal() const;
        -:  700:};
        -:  701:
        -:  702:typedef Scalar_<double> Scalar;
        -:  703:
        -:  704:template<typename _Tp> class DataType< Scalar_<_Tp> >
        -:  705:{
        -:  706:public:
        -:  707:    typedef Scalar_<_Tp>                               value_type;
        -:  708:    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;
        -:  709:    typedef _Tp                                        channel_type;
        -:  710:
        -:  711:    enum { generic_type = 0,
        -:  712:           channels     = 4,
        -:  713:           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)
        -:  714:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  715:           ,depth        = DataType<channel_type>::depth
        -:  716:           ,type         = CV_MAKETYPE(depth, channels)
        -:  717:#endif
        -:  718:         };
        -:  719:
        -:  720:    typedef Vec<channel_type, channels> vec_type;
        -:  721:};
        -:  722:
        -:  723:namespace traits {
        -:  724:template<typename _Tp>
        -:  725:struct Depth< Scalar_<_Tp> > { enum { value = Depth<_Tp>::value }; };
        -:  726:template<typename _Tp>
        -:  727:struct Type< Scalar_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };
        -:  728:} // namespace
        -:  729:
        -:  730:
        -:  731://///////////////////////////// KeyPoint ////////////////////////////////
        -:  732:
        -:  733:/** @brief Data structure for salient point detectors.
        -:  734:
        -:  735:The class instance stores a keypoint, i.e. a point feature found by one of many available keypoint
        -:  736:detectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.
        -:  737:
        -:  738:The keypoint is characterized by the 2D position, scale (proportional to the diameter of the
        -:  739:neighborhood that needs to be taken into account), orientation and some other parameters. The
        -:  740:keypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually
        -:  741:represented as a feature vector). The keypoints representing the same object in different images
        -:  742:can then be matched using %KDTree or another method.
        -:  743:*/
        -:  744:class CV_EXPORTS_W_SIMPLE KeyPoint
        -:  745:{
        -:  746:public:
        -:  747:    //! the default constructor
        -:  748:    CV_WRAP KeyPoint();
        -:  749:    /**
        -:  750:    @param pt x & y coordinates of the keypoint
        -:  751:    @param size keypoint diameter
        -:  752:    @param angle keypoint orientation
        -:  753:    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  754:    @param octave pyramid octave in which the keypoint has been detected
        -:  755:    @param class_id object id
        -:  756:     */
        -:  757:    KeyPoint(Point2f pt, float size, float angle=-1, float response=0, int octave=0, int class_id=-1);
        -:  758:    /**
        -:  759:    @param x x-coordinate of the keypoint
        -:  760:    @param y y-coordinate of the keypoint
        -:  761:    @param size keypoint diameter
        -:  762:    @param angle keypoint orientation
        -:  763:    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  764:    @param octave pyramid octave in which the keypoint has been detected
        -:  765:    @param class_id object id
        -:  766:     */
        -:  767:    CV_WRAP KeyPoint(float x, float y, float size, float angle=-1, float response=0, int octave=0, int class_id=-1);
        -:  768:
        -:  769:    size_t hash() const;
        -:  770:
        -:  771:    /**
        -:  772:    This method converts vector of keypoints to vector of points or the reverse, where each keypoint is
        -:  773:    assigned the same size and the same orientation.
        -:  774:
        -:  775:    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
        -:  776:    @param points2f Array of (x,y) coordinates of each keypoint
        -:  777:    @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to
        -:  778:    convert only specified keypoints)
        -:  779:    */
        -:  780:    CV_WRAP static void convert(const std::vector<KeyPoint>& keypoints,
        -:  781:                                CV_OUT std::vector<Point2f>& points2f,
        -:  782:                                const std::vector<int>& keypointIndexes=std::vector<int>());
        -:  783:    /** @overload
        -:  784:    @param points2f Array of (x,y) coordinates of each keypoint
        -:  785:    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB
        -:  786:    @param size keypoint diameter
        -:  787:    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)
        -:  788:    @param octave pyramid octave in which the keypoint has been detected
        -:  789:    @param class_id object id
        -:  790:    */
        -:  791:    CV_WRAP static void convert(const std::vector<Point2f>& points2f,
        -:  792:                                CV_OUT std::vector<KeyPoint>& keypoints,
        -:  793:                                float size=1, float response=1, int octave=0, int class_id=-1);
        -:  794:
        -:  795:    /**
        -:  796:    This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint
        -:  797:    regions' intersection and area of keypoint regions' union (considering keypoint region as circle).
        -:  798:    If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.
        -:  799:    @param kp1 First keypoint
        -:  800:    @param kp2 Second keypoint
        -:  801:    */
        -:  802:    CV_WRAP static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);
        -:  803:
        -:  804:    CV_PROP_RW Point2f pt; //!< coordinates of the keypoints
        -:  805:    CV_PROP_RW float size; //!< diameter of the meaningful keypoint neighborhood
        -:  806:    CV_PROP_RW float angle; //!< computed orientation of the keypoint (-1 if not applicable);
        -:  807:                            //!< it's in [0,360) degrees and measured relative to
        -:  808:                            //!< image coordinate system, ie in clockwise.
        -:  809:    CV_PROP_RW float response; //!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling
        -:  810:    CV_PROP_RW int octave; //!< octave (pyramid layer) from which the keypoint has been extracted
        -:  811:    CV_PROP_RW int class_id; //!< object class (if the keypoints need to be clustered by an object they belong to)
        -:  812:};
        -:  813:
        -:  814:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  815:template<> class DataType<KeyPoint>
        -:  816:{
        -:  817:public:
        -:  818:    typedef KeyPoint      value_type;
        -:  819:    typedef float         work_type;
        -:  820:    typedef float         channel_type;
        -:  821:
        -:  822:    enum { generic_type = 0,
        -:  823:           depth        = DataType<channel_type>::depth,
        -:  824:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 7
        -:  825:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
        -:  826:           type         = CV_MAKETYPE(depth, channels)
        -:  827:         };
        -:  828:
        -:  829:    typedef Vec<channel_type, channels> vec_type;
        -:  830:};
        -:  831:#endif
        -:  832:
        -:  833:
        -:  834://////////////////////////////// DMatch /////////////////////////////////
        -:  835:
        -:  836:/** @brief Class for matching keypoint descriptors
        -:  837:
        -:  838:query descriptor index, train descriptor index, train image index, and distance between
        -:  839:descriptors.
        -:  840:*/
        -:  841:class CV_EXPORTS_W_SIMPLE DMatch
        -:  842:{
        -:  843:public:
        -:  844:    CV_WRAP DMatch();
        -:  845:    CV_WRAP DMatch(int _queryIdx, int _trainIdx, float _distance);
        -:  846:    CV_WRAP DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);
        -:  847:
        -:  848:    CV_PROP_RW int queryIdx; //!< query descriptor index
        -:  849:    CV_PROP_RW int trainIdx; //!< train descriptor index
        -:  850:    CV_PROP_RW int imgIdx;   //!< train image index
        -:  851:
        -:  852:    CV_PROP_RW float distance;
        -:  853:
        -:  854:    // less is better
        -:  855:    bool operator<(const DMatch &m) const;
        -:  856:};
        -:  857:
        -:  858:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  859:template<> class DataType<DMatch>
        -:  860:{
        -:  861:public:
        -:  862:    typedef DMatch      value_type;
        -:  863:    typedef int         work_type;
        -:  864:    typedef int         channel_type;
        -:  865:
        -:  866:    enum { generic_type = 0,
        -:  867:           depth        = DataType<channel_type>::depth,
        -:  868:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 4
        -:  869:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),
        -:  870:           type         = CV_MAKETYPE(depth, channels)
        -:  871:         };
        -:  872:
        -:  873:    typedef Vec<channel_type, channels> vec_type;
        -:  874:};
        -:  875:#endif
        -:  876:
        -:  877:
        -:  878:///////////////////////////// TermCriteria //////////////////////////////
        -:  879:
        -:  880:/** @brief The class defining termination criteria for iterative algorithms.
        -:  881:
        -:  882:You can initialize it by default constructor and then override any parameters, or the structure may
        -:  883:be fully initialized using the advanced variant of the constructor.
        -:  884:*/
        -:  885:class CV_EXPORTS TermCriteria
        -:  886:{
        -:  887:public:
        -:  888:    /**
        -:  889:      Criteria type, can be one of: COUNT, EPS or COUNT + EPS
        -:  890:    */
        -:  891:    enum Type
        -:  892:    {
        -:  893:        COUNT=1, //!< the maximum number of iterations or elements to compute
        -:  894:        MAX_ITER=COUNT, //!< ditto
        -:  895:        EPS=2 //!< the desired accuracy or change in parameters at which the iterative algorithm stops
        -:  896:    };
        -:  897:
        -:  898:    //! default constructor
        -:  899:    TermCriteria();
        -:  900:    /**
        -:  901:    @param type The type of termination criteria, one of TermCriteria::Type
        -:  902:    @param maxCount The maximum number of iterations or elements to compute.
        -:  903:    @param epsilon The desired accuracy or change in parameters at which the iterative algorithm stops.
        -:  904:    */
        -:  905:    TermCriteria(int type, int maxCount, double epsilon);
        -:  906:
        -:  907:    inline bool isValid() const
        -:  908:    {
        -:  909:        const bool isCount = (type & COUNT) && maxCount > 0;
        -:  910:        const bool isEps = (type & EPS) && !cvIsNaN(epsilon);
        -:  911:        return isCount || isEps;
        -:  912:    }
        -:  913:
        -:  914:    int type; //!< the type of termination criteria: COUNT, EPS or COUNT + EPS
        -:  915:    int maxCount; //!< the maximum number of iterations/elements
        -:  916:    double epsilon; //!< the desired accuracy
        -:  917:};
        -:  918:
        -:  919:
        -:  920://! @} core_basic
        -:  921:
        -:  922:///////////////////////// raster image moments //////////////////////////
        -:  923:
        -:  924://! @addtogroup imgproc_shape
        -:  925://! @{
        -:  926:
        -:  927:/** @brief struct returned by cv::moments
        -:  928:
        -:  929:The spatial moments \f$\texttt{Moments::m}_{ji}\f$ are computed as:
        -:  930:
        -:  931:\f[\texttt{m} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot x^j  \cdot y^i \right )\f]
        -:  932:
        -:  933:The central moments \f$\texttt{Moments::mu}_{ji}\f$ are computed as:
        -:  934:
        -:  935:\f[\texttt{mu} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot (x -  \bar{x} )^j  \cdot (y -  \bar{y} )^i \right )\f]
        -:  936:
        -:  937:where \f$(\bar{x}, \bar{y})\f$ is the mass center:
        -:  938:
        -:  939:\f[\bar{x} = \frac{\texttt{m}_{10}}{\texttt{m}_{00}} , \; \bar{y} = \frac{\texttt{m}_{01}}{\texttt{m}_{00}}\f]
        -:  940:
        -:  941:The normalized central moments \f$\texttt{Moments::nu}_{ij}\f$ are computed as:
        -:  942:
        -:  943:\f[\texttt{nu} _{ji}= \frac{\texttt{mu}_{ji}}{\texttt{m}_{00}^{(i+j)/2+1}} .\f]
        -:  944:
        -:  945:@note
        -:  946:\f$\texttt{mu}_{00}=\texttt{m}_{00}\f$, \f$\texttt{nu}_{00}=1\f$
        -:  947:\f$\texttt{nu}_{10}=\texttt{mu}_{10}=\texttt{mu}_{01}=\texttt{mu}_{10}=0\f$ , hence the values are not
        -:  948:stored.
        -:  949:
        -:  950:The moments of a contour are defined in the same way but computed using the Green's formula (see
        -:  951:<http://en.wikipedia.org/wiki/Green_theorem>). So, due to a limited raster resolution, the moments
        -:  952:computed for a contour are slightly different from the moments computed for the same rasterized
        -:  953:contour.
        -:  954:
        -:  955:@note
        -:  956:Since the contour moments are computed using Green formula, you may get seemingly odd results for
        -:  957:contours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours.
        -:  958: */
        -:  959:class CV_EXPORTS_W_MAP Moments
        -:  960:{
        -:  961:public:
        -:  962:    //! the default constructor
        -:  963:    Moments();
        -:  964:    //! the full constructor
        -:  965:    Moments(double m00, double m10, double m01, double m20, double m11,
        -:  966:            double m02, double m30, double m21, double m12, double m03 );
        -:  967:    ////! the conversion from CvMoments
        -:  968:    //Moments( const CvMoments& moments );
        -:  969:    ////! the conversion to CvMoments
        -:  970:    //operator CvMoments() const;
        -:  971:
        -:  972:    //! @name spatial moments
        -:  973:    //! @{
        -:  974:    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;
        -:  975:    //! @}
        -:  976:
        -:  977:    //! @name central moments
        -:  978:    //! @{
        -:  979:    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;
        -:  980:    //! @}
        -:  981:
        -:  982:    //! @name central normalized moments
        -:  983:    //! @{
        -:  984:    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;
        -:  985:    //! @}
        -:  986:};
        -:  987:
        -:  988:template<> class DataType<Moments>
        -:  989:{
        -:  990:public:
        -:  991:    typedef Moments     value_type;
        -:  992:    typedef double      work_type;
        -:  993:    typedef double      channel_type;
        -:  994:
        -:  995:    enum { generic_type = 0,
        -:  996:           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 24
        -:  997:           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)
        -:  998:#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED
        -:  999:           ,depth        = DataType<channel_type>::depth
        -: 1000:           ,type         = CV_MAKETYPE(depth, channels)
        -: 1001:#endif
        -: 1002:         };
        -: 1003:
        -: 1004:    typedef Vec<channel_type, channels> vec_type;
        -: 1005:};
        -: 1006:
        -: 1007:namespace traits {
        -: 1008:template<>
        -: 1009:struct Depth< Moments > { enum { value = Depth<double>::value }; };
        -: 1010:template<>
        -: 1011:struct Type< Moments > { enum { value = CV_MAKETYPE(Depth<double>::value, (int)(sizeof(Moments)/sizeof(double))) }; };
        -: 1012:} // namespace
        -: 1013:
        -: 1014://! @} imgproc_shape
        -: 1015:
        -: 1016://! @cond IGNORED
        -: 1017:
        -: 1018://///////////////////////////////////////////////////////////////////////
        -: 1019:///////////////////////////// Implementation ////////////////////////////
        -: 1020://///////////////////////////////////////////////////////////////////////
        -: 1021:
        -: 1022://////////////////////////////// Complex ////////////////////////////////
        -: 1023:
        -: 1024:template<typename _Tp> inline
        -: 1025:Complex<_Tp>::Complex()
        -: 1026:    : re(0), im(0) {}
        -: 1027:
        -: 1028:template<typename _Tp> inline
        -: 1029:Complex<_Tp>::Complex( _Tp _re, _Tp _im )
        -: 1030:    : re(_re), im(_im) {}
        -: 1031:
        -: 1032:template<typename _Tp> template<typename T2> inline
        -: 1033:Complex<_Tp>::operator Complex<T2>() const
        -: 1034:{
        -: 1035:    return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im));
        -: 1036:}
        -: 1037:
        -: 1038:template<typename _Tp> inline
        -: 1039:Complex<_Tp> Complex<_Tp>::conj() const
        -: 1040:{
        -: 1041:    return Complex<_Tp>(re, -im);
        -: 1042:}
        -: 1043:
        -: 1044:
        -: 1045:template<typename _Tp> static inline
        -: 1046:bool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1047:{
        -: 1048:    return a.re == b.re && a.im == b.im;
        -: 1049:}
        -: 1050:
        -: 1051:template<typename _Tp> static inline
        -: 1052:bool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1053:{
        -: 1054:    return a.re != b.re || a.im != b.im;
        -: 1055:}
        -: 1056:
        -: 1057:template<typename _Tp> static inline
        -: 1058:Complex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1059:{
        -: 1060:    return Complex<_Tp>( a.re + b.re, a.im + b.im );
        -: 1061:}
        -: 1062:
        -: 1063:template<typename _Tp> static inline
        -: 1064:Complex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1065:{
        -: 1066:    a.re += b.re; a.im += b.im;
        -: 1067:    return a;
        -: 1068:}
        -: 1069:
        -: 1070:template<typename _Tp> static inline
        -: 1071:Complex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1072:{
        -: 1073:    return Complex<_Tp>( a.re - b.re, a.im - b.im );
        -: 1074:}
        -: 1075:
        -: 1076:template<typename _Tp> static inline
        -: 1077:Complex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1078:{
        -: 1079:    a.re -= b.re; a.im -= b.im;
        -: 1080:    return a;
        -: 1081:}
        -: 1082:
        -: 1083:template<typename _Tp> static inline
        -: 1084:Complex<_Tp> operator - (const Complex<_Tp>& a)
        -: 1085:{
        -: 1086:    return Complex<_Tp>(-a.re, -a.im);
        -: 1087:}
        -: 1088:
        -: 1089:template<typename _Tp> static inline
        -: 1090:Complex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1091:{
        -: 1092:    return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re );
        -: 1093:}
        -: 1094:
        -: 1095:template<typename _Tp> static inline
        -: 1096:Complex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)
        -: 1097:{
        -: 1098:    return Complex<_Tp>( a.re*b, a.im*b );
        -: 1099:}
        -: 1100:
        -: 1101:template<typename _Tp> static inline
        -: 1102:Complex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)
        -: 1103:{
        -: 1104:    return Complex<_Tp>( a.re*b, a.im*b );
        -: 1105:}
        -: 1106:
        -: 1107:template<typename _Tp> static inline
        -: 1108:Complex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)
        -: 1109:{
        -: 1110:    return Complex<_Tp>( a.re + b, a.im );
        -: 1111:}
        -: 1112:
        -: 1113:template<typename _Tp> static inline
        -: 1114:Complex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)
        -: 1115:{ return Complex<_Tp>( a.re - b, a.im ); }
        -: 1116:
        -: 1117:template<typename _Tp> static inline
        -: 1118:Complex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)
        -: 1119:{
        -: 1120:    return Complex<_Tp>( a.re + b, a.im );
        -: 1121:}
        -: 1122:
        -: 1123:template<typename _Tp> static inline
        -: 1124:Complex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)
        -: 1125:{
        -: 1126:    return Complex<_Tp>( b - a.re, -a.im );
        -: 1127:}
        -: 1128:
        -: 1129:template<typename _Tp> static inline
        -: 1130:Complex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)
        -: 1131:{
        -: 1132:    a.re += b; return a;
        -: 1133:}
        -: 1134:
        -: 1135:template<typename _Tp> static inline
        -: 1136:Complex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)
        -: 1137:{
        -: 1138:    a.re -= b; return a;
        -: 1139:}
        -: 1140:
        -: 1141:template<typename _Tp> static inline
        -: 1142:Complex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)
        -: 1143:{
        -: 1144:    a.re *= b; a.im *= b; return a;
        -: 1145:}
        -: 1146:
        -: 1147:template<typename _Tp> static inline
        -: 1148:double abs(const Complex<_Tp>& a)
        -: 1149:{
        -: 1150:    return std::sqrt( (double)a.re*a.re + (double)a.im*a.im);
        -: 1151:}
        -: 1152:
        -: 1153:template<typename _Tp> static inline
        -: 1154:Complex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1155:{
        -: 1156:    double t = 1./((double)b.re*b.re + (double)b.im*b.im);
        -: 1157:    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),
        -: 1158:                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );
        -: 1159:}
        -: 1160:
        -: 1161:template<typename _Tp> static inline
        -: 1162:Complex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)
        -: 1163:{
        -: 1164:    a = a / b;
        -: 1165:    return a;
        -: 1166:}
        -: 1167:
        -: 1168:template<typename _Tp> static inline
        -: 1169:Complex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)
        -: 1170:{
        -: 1171:    _Tp t = (_Tp)1/b;
        -: 1172:    return Complex<_Tp>( a.re*t, a.im*t );
        -: 1173:}
        -: 1174:
        -: 1175:template<typename _Tp> static inline
        -: 1176:Complex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)
        -: 1177:{
        -: 1178:    return Complex<_Tp>(b)/a;
        -: 1179:}
        -: 1180:
        -: 1181:template<typename _Tp> static inline
        -: 1182:Complex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)
        -: 1183:{
        -: 1184:    _Tp t = (_Tp)1/b;
        -: 1185:    a.re *= t; a.im *= t; return a;
        -: 1186:}
        -: 1187:
        -: 1188:
        -: 1189:
        -: 1190://////////////////////////////// 2D Point ///////////////////////////////
        -: 1191:
        -: 1192:template<typename _Tp> inline
        -: 1193:Point_<_Tp>::Point_()
        -: 1194:    : x(0), y(0) {}
        -: 1195:
        -: 1196:template<typename _Tp> inline
        -: 1197:Point_<_Tp>::Point_(_Tp _x, _Tp _y)
        -: 1198:    : x(_x), y(_y) {}
        -: 1199:
        -: 1200:#if (defined(__GNUC__) && __GNUC__ < 5) && !defined(__clang__)  // GCC 4.x bug. Details: https://github.com/opencv/opencv/pull/20837
        -: 1201:template<typename _Tp> inline
        -: 1202:Point_<_Tp>::Point_(const Point_& pt)
        -: 1203:    : x(pt.x), y(pt.y) {}
        -: 1204:#endif
        -: 1205:
        -: 1206:template<typename _Tp> inline
        -: 1207:Point_<_Tp>::Point_(const Size_<_Tp>& sz)
        -: 1208:    : x(sz.width), y(sz.height) {}
        -: 1209:
        -: 1210:template<typename _Tp> inline
        -: 1211:Point_<_Tp>::Point_(const Vec<_Tp,2>& v)
        -: 1212:    : x(v[0]), y(v[1]) {}
        -: 1213:
        -: 1214:#if (defined(__GNUC__) && __GNUC__ < 5) && !defined(__clang__)  // GCC 4.x bug. Details: https://github.com/opencv/opencv/pull/20837
        -: 1215:template<typename _Tp> inline
        -: 1216:Point_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)
        -: 1217:{
        -: 1218:    x = pt.x; y = pt.y;
        -: 1219:    return *this;
        -: 1220:}
        -: 1221:#endif
        -: 1222:
        -: 1223:template<typename _Tp> template<typename _Tp2> inline
        -: 1224:Point_<_Tp>::operator Point_<_Tp2>() const
        -: 1225:{
        -: 1226:    return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y));
        -: 1227:}
        -: 1228:
        -: 1229:template<typename _Tp> inline
        -: 1230:Point_<_Tp>::operator Vec<_Tp, 2>() const
        -: 1231:{
        -: 1232:    return Vec<_Tp, 2>(x, y);
        -: 1233:}
        -: 1234:
        -: 1235:template<typename _Tp> inline
        -: 1236:_Tp Point_<_Tp>::dot(const Point_& pt) const
        -: 1237:{
        -: 1238:    return saturate_cast<_Tp>(x*pt.x + y*pt.y);
        -: 1239:}
        -: 1240:
        -: 1241:template<typename _Tp> inline
        -: 1242:double Point_<_Tp>::ddot(const Point_& pt) const
        -: 1243:{
        -: 1244:    return (double)x*(double)(pt.x) + (double)y*(double)(pt.y);
        -: 1245:}
        -: 1246:
        -: 1247:template<typename _Tp> inline
        -: 1248:double Point_<_Tp>::cross(const Point_& pt) const
        -: 1249:{
        -: 1250:    return (double)x*pt.y - (double)y*pt.x;
        -: 1251:}
        -: 1252:
        -: 1253:template<typename _Tp> inline bool
        -: 1254:Point_<_Tp>::inside( const Rect_<_Tp>& r ) const
        -: 1255:{
        -: 1256:    return r.contains(*this);
        -: 1257:}
        -: 1258:
        -: 1259:
        -: 1260:template<typename _Tp> static inline
        -: 1261:Point_<_Tp>& operator += (Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1262:{
        -: 1263:    a.x += b.x;
        -: 1264:    a.y += b.y;
        -: 1265:    return a;
        -: 1266:}
        -: 1267:
        -: 1268:template<typename _Tp> static inline
        -: 1269:Point_<_Tp>& operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1270:{
        -: 1271:    a.x -= b.x;
        -: 1272:    a.y -= b.y;
        -: 1273:    return a;
        -: 1274:}
        -: 1275:
        -: 1276:template<typename _Tp> static inline
        -: 1277:Point_<_Tp>& operator *= (Point_<_Tp>& a, int b)
        -: 1278:{
        -: 1279:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1280:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1281:    return a;
        -: 1282:}
        -: 1283:
        -: 1284:template<typename _Tp> static inline
        -: 1285:Point_<_Tp>& operator *= (Point_<_Tp>& a, float b)
        -: 1286:{
        -: 1287:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1288:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1289:    return a;
        -: 1290:}
        -: 1291:
        -: 1292:template<typename _Tp> static inline
        -: 1293:Point_<_Tp>& operator *= (Point_<_Tp>& a, double b)
        -: 1294:{
        -: 1295:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1296:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1297:    return a;
        -: 1298:}
        -: 1299:
        -: 1300:template<typename _Tp> static inline
        -: 1301:Point_<_Tp>& operator /= (Point_<_Tp>& a, int b)
        -: 1302:{
        -: 1303:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1304:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1305:    return a;
        -: 1306:}
        -: 1307:
        -: 1308:template<typename _Tp> static inline
        -: 1309:Point_<_Tp>& operator /= (Point_<_Tp>& a, float b)
        -: 1310:{
        -: 1311:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1312:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1313:    return a;
        -: 1314:}
        -: 1315:
        -: 1316:template<typename _Tp> static inline
        -: 1317:Point_<_Tp>& operator /= (Point_<_Tp>& a, double b)
        -: 1318:{
        -: 1319:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1320:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1321:    return a;
        -: 1322:}
        -: 1323:
        -: 1324:template<typename _Tp> static inline
        -: 1325:double norm(const Point_<_Tp>& pt)
        -: 1326:{
        -: 1327:    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y);
        -: 1328:}
        -: 1329:
        -: 1330:template<typename _Tp> static inline
        -: 1331:bool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1332:{
        -: 1333:    return a.x == b.x && a.y == b.y;
        -: 1334:}
        -: 1335:
        -: 1336:template<typename _Tp> static inline
        -: 1337:bool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1338:{
        -: 1339:    return a.x != b.x || a.y != b.y;
        -: 1340:}
        -: 1341:
        -: 1342:template<typename _Tp> static inline
        -: 1343:Point_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1344:{
        -: 1345:    return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) );
        -: 1346:}
        -: 1347:
        -: 1348:template<typename _Tp> static inline
        -: 1349:Point_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)
        -: 1350:{
        -: 1351:    return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) );
        -: 1352:}
        -: 1353:
        -: 1354:template<typename _Tp> static inline
        -: 1355:Point_<_Tp> operator - (const Point_<_Tp>& a)
        -: 1356:{
        -: 1357:    return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) );
        -: 1358:}
        -: 1359:
        -: 1360:template<typename _Tp> static inline
        -: 1361:Point_<_Tp> operator * (const Point_<_Tp>& a, int b)
        -: 1362:{
        -: 1363:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1364:}
        -: 1365:
        -: 1366:template<typename _Tp> static inline
        -: 1367:Point_<_Tp> operator * (int a, const Point_<_Tp>& b)
        -: 1368:{
        -: 1369:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1370:}
        -: 1371:
        -: 1372:template<typename _Tp> static inline
        -: 1373:Point_<_Tp> operator * (const Point_<_Tp>& a, float b)
        -: 1374:{
        -: 1375:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1376:}
        -: 1377:
        -: 1378:template<typename _Tp> static inline
        -: 1379:Point_<_Tp> operator * (float a, const Point_<_Tp>& b)
        -: 1380:{
        -: 1381:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1382:}
        -: 1383:
        -: 1384:template<typename _Tp> static inline
        -: 1385:Point_<_Tp> operator * (const Point_<_Tp>& a, double b)
        -: 1386:{
        -: 1387:    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );
        -: 1388:}
        -: 1389:
        -: 1390:template<typename _Tp> static inline
        -: 1391:Point_<_Tp> operator * (double a, const Point_<_Tp>& b)
        -: 1392:{
        -: 1393:    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );
        -: 1394:}
        -: 1395:
        -: 1396:template<typename _Tp> static inline
        -: 1397:Point_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)
        -: 1398:{
        -: 1399:    Matx<_Tp, 2, 1> tmp = a * Vec<_Tp,2>(b.x, b.y);
        -: 1400:    return Point_<_Tp>(tmp.val[0], tmp.val[1]);
        -: 1401:}
        -: 1402:
        -: 1403:template<typename _Tp> static inline
        -: 1404:Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)
        -: 1405:{
        -: 1406:    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, 1);
        -: 1407:    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
        -: 1408:}
        -: 1409:
        -: 1410:template<typename _Tp> static inline
        -: 1411:Point_<_Tp> operator / (const Point_<_Tp>& a, int b)
        -: 1412:{
        -: 1413:    Point_<_Tp> tmp(a);
        -: 1414:    tmp /= b;
        -: 1415:    return tmp;
        -: 1416:}
        -: 1417:
        -: 1418:template<typename _Tp> static inline
        -: 1419:Point_<_Tp> operator / (const Point_<_Tp>& a, float b)
        -: 1420:{
        -: 1421:    Point_<_Tp> tmp(a);
        -: 1422:    tmp /= b;
        -: 1423:    return tmp;
        -: 1424:}
        -: 1425:
        -: 1426:template<typename _Tp> static inline
        -: 1427:Point_<_Tp> operator / (const Point_<_Tp>& a, double b)
        -: 1428:{
        -: 1429:    Point_<_Tp> tmp(a);
        -: 1430:    tmp /= b;
        -: 1431:    return tmp;
        -: 1432:}
        -: 1433:
        -: 1434:
        -: 1435:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int>& pt);
        -: 1436:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int64>& pt);
        -: 1437:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<float>& pt);
        -: 1438:template<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<double>& pt);
        -: 1439:
        -: 1440:template<> inline int normL2Sqr<int>(const Point_<int>& pt) { return pt.dot(pt); }
        -: 1441:template<> inline int64 normL2Sqr<int64>(const Point_<int64>& pt) { return pt.dot(pt); }
        -: 1442:template<> inline float normL2Sqr<float>(const Point_<float>& pt) { return pt.dot(pt); }
        -: 1443:template<> inline double normL2Sqr<double>(const Point_<int>& pt) { return pt.dot(pt); }
        -: 1444:
        -: 1445:template<> inline double normL2Sqr<double>(const Point_<float>& pt) { return pt.ddot(pt); }
        -: 1446:template<> inline double normL2Sqr<double>(const Point_<double>& pt) { return pt.ddot(pt); }
        -: 1447:
        -: 1448:
        -: 1449:
        -: 1450://////////////////////////////// 3D Point ///////////////////////////////
        -: 1451:
        -: 1452:template<typename _Tp> inline
        -: 1453:Point3_<_Tp>::Point3_()
        -: 1454:    : x(0), y(0), z(0) {}
        -: 1455:
        -: 1456:template<typename _Tp> inline
        -: 1457:Point3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z)
        -: 1458:    : x(_x), y(_y), z(_z) {}
        -: 1459:
        -: 1460:template<typename _Tp> inline
        -: 1461:Point3_<_Tp>::Point3_(const Point_<_Tp>& pt)
        -: 1462:    : x(pt.x), y(pt.y), z(_Tp()) {}
        -: 1463:
        -: 1464:template<typename _Tp> inline
        -: 1465:Point3_<_Tp>::Point3_(const Vec<_Tp, 3>& v)
        -: 1466:    : x(v[0]), y(v[1]), z(v[2]) {}
        -: 1467:
        -: 1468:template<typename _Tp> template<typename _Tp2> inline
        -: 1469:Point3_<_Tp>::operator Point3_<_Tp2>() const
        -: 1470:{
        -: 1471:    return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z));
        -: 1472:}
        -: 1473:
        -: 1474:template<typename _Tp> inline
        -: 1475:Point3_<_Tp>::operator Vec<_Tp, 3>() const
        -: 1476:{
        -: 1477:    return Vec<_Tp, 3>(x, y, z);
        -: 1478:}
        -: 1479:
        -: 1480:template<typename _Tp> inline
        -: 1481:_Tp Point3_<_Tp>::dot(const Point3_& pt) const
        -: 1482:{
        -: 1483:    return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z);
        -: 1484:}
        -: 1485:
        -: 1486:template<typename _Tp> inline
        -: 1487:double Point3_<_Tp>::ddot(const Point3_& pt) const
        -: 1488:{
        -: 1489:    return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z;
        -: 1490:}
        -: 1491:
        -: 1492:template<typename _Tp> inline
        -: 1493:Point3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const
        -: 1494:{
        -: 1495:    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);
        -: 1496:}
        -: 1497:
        -: 1498:
        -: 1499:template<typename _Tp> static inline
        -: 1500:Point3_<_Tp>& operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1501:{
        -: 1502:    a.x += b.x;
        -: 1503:    a.y += b.y;
        -: 1504:    a.z += b.z;
        -: 1505:    return a;
        -: 1506:}
        -: 1507:
        -: 1508:template<typename _Tp> static inline
        -: 1509:Point3_<_Tp>& operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1510:{
        -: 1511:    a.x -= b.x;
        -: 1512:    a.y -= b.y;
        -: 1513:    a.z -= b.z;
        -: 1514:    return a;
        -: 1515:}
        -: 1516:
        -: 1517:template<typename _Tp> static inline
        -: 1518:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, int b)
        -: 1519:{
        -: 1520:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1521:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1522:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1523:    return a;
        -: 1524:}
        -: 1525:
        -: 1526:template<typename _Tp> static inline
        -: 1527:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, float b)
        -: 1528:{
        -: 1529:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1530:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1531:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1532:    return a;
        -: 1533:}
        -: 1534:
        -: 1535:template<typename _Tp> static inline
        -: 1536:Point3_<_Tp>& operator *= (Point3_<_Tp>& a, double b)
        -: 1537:{
        -: 1538:    a.x = saturate_cast<_Tp>(a.x * b);
        -: 1539:    a.y = saturate_cast<_Tp>(a.y * b);
        -: 1540:    a.z = saturate_cast<_Tp>(a.z * b);
        -: 1541:    return a;
        -: 1542:}
        -: 1543:
        -: 1544:template<typename _Tp> static inline
        -: 1545:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, int b)
        -: 1546:{
        -: 1547:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1548:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1549:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1550:    return a;
        -: 1551:}
        -: 1552:
        -: 1553:template<typename _Tp> static inline
        -: 1554:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, float b)
        -: 1555:{
        -: 1556:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1557:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1558:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1559:    return a;
        -: 1560:}
        -: 1561:
        -: 1562:template<typename _Tp> static inline
        -: 1563:Point3_<_Tp>& operator /= (Point3_<_Tp>& a, double b)
        -: 1564:{
        -: 1565:    a.x = saturate_cast<_Tp>(a.x / b);
        -: 1566:    a.y = saturate_cast<_Tp>(a.y / b);
        -: 1567:    a.z = saturate_cast<_Tp>(a.z / b);
        -: 1568:    return a;
        -: 1569:}
        -: 1570:
        -: 1571:template<typename _Tp> static inline
        -: 1572:double norm(const Point3_<_Tp>& pt)
        -: 1573:{
        -: 1574:    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z);
        -: 1575:}
        -: 1576:
        -: 1577:template<typename _Tp> static inline
        -: 1578:bool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1579:{
        -: 1580:    return a.x == b.x && a.y == b.y && a.z == b.z;
        -: 1581:}
        -: 1582:
        -: 1583:template<typename _Tp> static inline
        -: 1584:bool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1585:{
        -: 1586:    return a.x != b.x || a.y != b.y || a.z != b.z;
        -: 1587:}
        -: 1588:
        -: 1589:template<typename _Tp> static inline
        -: 1590:Point3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1591:{
        -: 1592:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y), saturate_cast<_Tp>(a.z + b.z));
        -: 1593:}
        -: 1594:
        -: 1595:template<typename _Tp> static inline
        -: 1596:Point3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)
        -: 1597:{
        -: 1598:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y), saturate_cast<_Tp>(a.z - b.z));
        -: 1599:}
        -: 1600:
        -: 1601:template<typename _Tp> static inline
        -: 1602:Point3_<_Tp> operator - (const Point3_<_Tp>& a)
        -: 1603:{
        -: 1604:    return Point3_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y), saturate_cast<_Tp>(-a.z) );
        -: 1605:}
        -: 1606:
        -: 1607:template<typename _Tp> static inline
        -: 1608:Point3_<_Tp> operator * (const Point3_<_Tp>& a, int b)
        -: 1609:{
        -: 1610:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b), saturate_cast<_Tp>(a.z*b) );
        -: 1611:}
        -: 1612:
        -: 1613:template<typename _Tp> static inline
        -: 1614:Point3_<_Tp> operator * (int a, const Point3_<_Tp>& b)
        -: 1615:{
        -: 1616:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1617:}
        -: 1618:
        -: 1619:template<typename _Tp> static inline
        -: 1620:Point3_<_Tp> operator * (const Point3_<_Tp>& a, float b)
        -: 1621:{
        -: 1622:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
        -: 1623:}
        -: 1624:
        -: 1625:template<typename _Tp> static inline
        -: 1626:Point3_<_Tp> operator * (float a, const Point3_<_Tp>& b)
        -: 1627:{
        -: 1628:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1629:}
        -: 1630:
        -: 1631:template<typename _Tp> static inline
        -: 1632:Point3_<_Tp> operator * (const Point3_<_Tp>& a, double b)
        -: 1633:{
        -: 1634:    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );
        -: 1635:}
        -: 1636:
        -: 1637:template<typename _Tp> static inline
        -: 1638:Point3_<_Tp> operator * (double a, const Point3_<_Tp>& b)
        -: 1639:{
        -: 1640:    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );
        -: 1641:}
        -: 1642:
        -: 1643:template<typename _Tp> static inline
        -: 1644:Point3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)
        -: 1645:{
        -: 1646:    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, b.z);
        -: 1647:    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);
        -: 1648:}
        -: 1649:
        -: 1650:template<typename _Tp> static inline
        -: 1651:Matx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)
        -: 1652:{
        -: 1653:    return a * Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);
        -: 1654:}
        -: 1655:
        -: 1656:template<typename _Tp> static inline
        -: 1657:Point3_<_Tp> operator / (const Point3_<_Tp>& a, int b)
        -: 1658:{
        -: 1659:    Point3_<_Tp> tmp(a);
        -: 1660:    tmp /= b;
        -: 1661:    return tmp;
        -: 1662:}
        -: 1663:
        -: 1664:template<typename _Tp> static inline
        -: 1665:Point3_<_Tp> operator / (const Point3_<_Tp>& a, float b)
        -: 1666:{
        -: 1667:    Point3_<_Tp> tmp(a);
        -: 1668:    tmp /= b;
        -: 1669:    return tmp;
        -: 1670:}
        -: 1671:
        -: 1672:template<typename _Tp> static inline
        -: 1673:Point3_<_Tp> operator / (const Point3_<_Tp>& a, double b)
        -: 1674:{
        -: 1675:    Point3_<_Tp> tmp(a);
        -: 1676:    tmp /= b;
        -: 1677:    return tmp;
        -: 1678:}
        -: 1679:
        -: 1680:
        -: 1681:
        -: 1682:////////////////////////////////// Size /////////////////////////////////
        -: 1683:
        -: 1684:template<typename _Tp> inline
function _ZN2cv5Size_IiEC2Ev called 34 returned 100% blocks executed 100%
       34: 1685:Size_<_Tp>::Size_()
       34: 1686:    : width(0), height(0) {}
        -: 1687:
        -: 1688:template<typename _Tp> inline
        -: 1689:Size_<_Tp>::Size_(_Tp _width, _Tp _height)
        -: 1690:    : width(_width), height(_height) {}
        -: 1691:
        -: 1692:template<typename _Tp> inline
        -: 1693:Size_<_Tp>::Size_(const Point_<_Tp>& pt)
        -: 1694:    : width(pt.x), height(pt.y) {}
        -: 1695:
        -: 1696:template<typename _Tp> template<typename _Tp2> inline
        -: 1697:Size_<_Tp>::operator Size_<_Tp2>() const
        -: 1698:{
        -: 1699:    return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
        -: 1700:}
        -: 1701:
        -: 1702:template<typename _Tp> inline
        -: 1703:_Tp Size_<_Tp>::area() const
        -: 1704:{
        -: 1705:    const _Tp result = width * height;
        -: 1706:    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer
        -: 1707:        || width == 0 || result / width == height); // make sure the result fits in the return value
        -: 1708:    return result;
        -: 1709:}
        -: 1710:
        -: 1711:template<typename _Tp> inline
        -: 1712:double Size_<_Tp>::aspectRatio() const
        -: 1713:{
        -: 1714:    return width / static_cast<double>(height);
        -: 1715:}
        -: 1716:
        -: 1717:template<typename _Tp> inline
        -: 1718:bool Size_<_Tp>::empty() const
        -: 1719:{
        -: 1720:    return width <= 0 || height <= 0;
        -: 1721:}
        -: 1722:
        -: 1723:
        -: 1724:template<typename _Tp> static inline
        -: 1725:Size_<_Tp>& operator *= (Size_<_Tp>& a, _Tp b)
        -: 1726:{
        -: 1727:    a.width *= b;
        -: 1728:    a.height *= b;
        -: 1729:    return a;
        -: 1730:}
        -: 1731:
        -: 1732:template<typename _Tp> static inline
        -: 1733:Size_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)
        -: 1734:{
        -: 1735:    Size_<_Tp> tmp(a);
        -: 1736:    tmp *= b;
        -: 1737:    return tmp;
        -: 1738:}
        -: 1739:
        -: 1740:template<typename _Tp> static inline
        -: 1741:Size_<_Tp>& operator /= (Size_<_Tp>& a, _Tp b)
        -: 1742:{
        -: 1743:    a.width /= b;
        -: 1744:    a.height /= b;
        -: 1745:    return a;
        -: 1746:}
        -: 1747:
        -: 1748:template<typename _Tp> static inline
        -: 1749:Size_<_Tp> operator / (const Size_<_Tp>& a, _Tp b)
        -: 1750:{
        -: 1751:    Size_<_Tp> tmp(a);
        -: 1752:    tmp /= b;
        -: 1753:    return tmp;
        -: 1754:}
        -: 1755:
        -: 1756:template<typename _Tp> static inline
        -: 1757:Size_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1758:{
        -: 1759:    a.width += b.width;
        -: 1760:    a.height += b.height;
        -: 1761:    return a;
        -: 1762:}
        -: 1763:
        -: 1764:template<typename _Tp> static inline
        -: 1765:Size_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1766:{
        -: 1767:    Size_<_Tp> tmp(a);
        -: 1768:    tmp += b;
        -: 1769:    return tmp;
        -: 1770:}
        -: 1771:
        -: 1772:template<typename _Tp> static inline
        -: 1773:Size_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1774:{
        -: 1775:    a.width -= b.width;
        -: 1776:    a.height -= b.height;
        -: 1777:    return a;
        -: 1778:}
        -: 1779:
        -: 1780:template<typename _Tp> static inline
        -: 1781:Size_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1782:{
        -: 1783:    Size_<_Tp> tmp(a);
        -: 1784:    tmp -= b;
        -: 1785:    return tmp;
        -: 1786:}
        -: 1787:
        -: 1788:template<typename _Tp> static inline
        -: 1789:bool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1790:{
        -: 1791:    return a.width == b.width && a.height == b.height;
        -: 1792:}
        -: 1793:
        -: 1794:template<typename _Tp> static inline
        -: 1795:bool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)
        -: 1796:{
        -: 1797:    return !(a == b);
        -: 1798:}
        -: 1799:
        -: 1800:
        -: 1801:
        -: 1802:////////////////////////////////// Rect /////////////////////////////////
        -: 1803:
        -: 1804:template<typename _Tp> inline
        -: 1805:Rect_<_Tp>::Rect_()
        -: 1806:    : x(0), y(0), width(0), height(0) {}
        -: 1807:
        -: 1808:template<typename _Tp> inline
        -: 1809:Rect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)
        -: 1810:    : x(_x), y(_y), width(_width), height(_height) {}
        -: 1811:
        -: 1812:template<typename _Tp> inline
        -: 1813:Rect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz)
        -: 1814:    : x(org.x), y(org.y), width(sz.width), height(sz.height) {}
        -: 1815:
        -: 1816:template<typename _Tp> inline
        -: 1817:Rect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)
        -: 1818:{
        -: 1819:    x = std::min(pt1.x, pt2.x);
        -: 1820:    y = std::min(pt1.y, pt2.y);
        -: 1821:    width = std::max(pt1.x, pt2.x) - x;
        -: 1822:    height = std::max(pt1.y, pt2.y) - y;
        -: 1823:}
        -: 1824:
        -: 1825:template<typename _Tp> inline
        -: 1826:Point_<_Tp> Rect_<_Tp>::tl() const
        -: 1827:{
        -: 1828:    return Point_<_Tp>(x,y);
        -: 1829:}
        -: 1830:
        -: 1831:template<typename _Tp> inline
        -: 1832:Point_<_Tp> Rect_<_Tp>::br() const
        -: 1833:{
        -: 1834:    return Point_<_Tp>(x + width, y + height);
        -: 1835:}
        -: 1836:
        -: 1837:template<typename _Tp> inline
        -: 1838:Size_<_Tp> Rect_<_Tp>::size() const
        -: 1839:{
        -: 1840:    return Size_<_Tp>(width, height);
        -: 1841:}
        -: 1842:
        -: 1843:template<typename _Tp> inline
        -: 1844:_Tp Rect_<_Tp>::area() const
        -: 1845:{
        -: 1846:    const _Tp result = width * height;
        -: 1847:    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer
        -: 1848:        || width == 0 || result / width == height); // make sure the result fits in the return value
        -: 1849:    return result;
        -: 1850:}
        -: 1851:
        -: 1852:template<typename _Tp> inline
        -: 1853:bool Rect_<_Tp>::empty() const
        -: 1854:{
        -: 1855:    return width <= 0 || height <= 0;
        -: 1856:}
        -: 1857:
        -: 1858:template<typename _Tp> template<typename _Tp2> inline
        -: 1859:Rect_<_Tp>::operator Rect_<_Tp2>() const
        -: 1860:{
        -: 1861:    return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));
        -: 1862:}
        -: 1863:
        -: 1864:template<typename _Tp> inline
        -: 1865:bool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const
        -: 1866:{
        -: 1867:    return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height;
        -: 1868:}
        -: 1869:
        -: 1870:
        -: 1871:template<typename _Tp> static inline
        -: 1872:Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )
        -: 1873:{
        -: 1874:    a.x += b.x;
        -: 1875:    a.y += b.y;
        -: 1876:    return a;
        -: 1877:}
        -: 1878:
        -: 1879:template<typename _Tp> static inline
        -: 1880:Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )
        -: 1881:{
        -: 1882:    a.x -= b.x;
        -: 1883:    a.y -= b.y;
        -: 1884:    return a;
        -: 1885:}
        -: 1886:
        -: 1887:template<typename _Tp> static inline
        -: 1888:Rect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )
        -: 1889:{
        -: 1890:    a.width += b.width;
        -: 1891:    a.height += b.height;
        -: 1892:    return a;
        -: 1893:}
        -: 1894:
        -: 1895:template<typename _Tp> static inline
        -: 1896:Rect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )
        -: 1897:{
        -: 1898:    const _Tp width = a.width - b.width;
        -: 1899:    const _Tp height = a.height - b.height;
        -: 1900:    CV_DbgAssert(width >= 0 && height >= 0);
        -: 1901:    a.width = width;
        -: 1902:    a.height = height;
        -: 1903:    return a;
        -: 1904:}
        -: 1905:
        -: 1906:template<typename _Tp> static inline
        -: 1907:Rect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
        -: 1908:{
        -: 1909:    if (a.empty() || b.empty()) {
        -: 1910:        a = Rect();
        -: 1911:        return a;
        -: 1912:    }
        -: 1913:    const Rect_<_Tp>& Rx_min = (a.x < b.x) ? a : b;
        -: 1914:    const Rect_<_Tp>& Rx_max = (a.x < b.x) ? b : a;
        -: 1915:    const Rect_<_Tp>& Ry_min = (a.y < b.y) ? a : b;
        -: 1916:    const Rect_<_Tp>& Ry_max = (a.y < b.y) ? b : a;
        -: 1917:    // Looking at the formula below, we will compute Rx_min.width - (Rx_max.x - Rx_min.x)
        -: 1918:    // but we want to avoid overflows. Rx_min.width >= 0 and (Rx_max.x - Rx_min.x) >= 0
        -: 1919:    // by definition so the difference does not overflow. The only thing that can overflow
        -: 1920:    // is (Rx_max.x - Rx_min.x). And it can only overflow if Rx_min.x < 0.
        -: 1921:    // Let us first deal with the following case.
        -: 1922:    if ((Rx_min.x < 0 && Rx_min.x + Rx_min.width < Rx_max.x) ||
        -: 1923:        (Ry_min.y < 0 && Ry_min.y + Ry_min.height < Ry_max.y)) {
        -: 1924:        a = Rect();
        -: 1925:        return a;
        -: 1926:    }
        -: 1927:    // We now know that either Rx_min.x >= 0, or
        -: 1928:    // Rx_min.x < 0 && Rx_min.x + Rx_min.width >= Rx_max.x and therefore
        -: 1929:    // Rx_min.width >= (Rx_max.x - Rx_min.x) which means (Rx_max.x - Rx_min.x)
        -: 1930:    // is inferior to a valid int and therefore does not overflow.
        -: 1931:    a.width = std::min(Rx_min.width - (Rx_max.x - Rx_min.x), Rx_max.width);
        -: 1932:    a.height = std::min(Ry_min.height - (Ry_max.y - Ry_min.y), Ry_max.height);
        -: 1933:    a.x = Rx_max.x;
        -: 1934:    a.y = Ry_max.y;
        -: 1935:    if (a.empty())
        -: 1936:        a = Rect();
        -: 1937:    return a;
        -: 1938:}
        -: 1939:
        -: 1940:template<typename _Tp> static inline
        -: 1941:Rect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )
        -: 1942:{
        -: 1943:    if (a.empty()) {
        -: 1944:        a = b;
        -: 1945:    }
        -: 1946:    else if (!b.empty()) {
        -: 1947:        _Tp x1 = std::min(a.x, b.x);
        -: 1948:        _Tp y1 = std::min(a.y, b.y);
        -: 1949:        a.width = std::max(a.x + a.width, b.x + b.width) - x1;
        -: 1950:        a.height = std::max(a.y + a.height, b.y + b.height) - y1;
        -: 1951:        a.x = x1;
        -: 1952:        a.y = y1;
        -: 1953:    }
        -: 1954:    return a;
        -: 1955:}
        -: 1956:
        -: 1957:template<typename _Tp> static inline
        -: 1958:bool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 1959:{
        -: 1960:    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;
        -: 1961:}
        -: 1962:
        -: 1963:template<typename _Tp> static inline
        -: 1964:bool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 1965:{
        -: 1966:    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;
        -: 1967:}
        -: 1968:
        -: 1969:template<typename _Tp> static inline
        -: 1970:Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)
        -: 1971:{
        -: 1972:    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );
        -: 1973:}
        -: 1974:
        -: 1975:template<typename _Tp> static inline
        -: 1976:Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)
        -: 1977:{
        -: 1978:    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );
        -: 1979:}
        -: 1980:
        -: 1981:template<typename _Tp> static inline
        -: 1982:Rect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)
        -: 1983:{
        -: 1984:    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );
        -: 1985:}
        -: 1986:
        -: 1987:template<typename _Tp> static inline
        -: 1988:Rect_<_Tp> operator - (const Rect_<_Tp>& a, const Size_<_Tp>& b)
        -: 1989:{
        -: 1990:    const _Tp width = a.width - b.width;
        -: 1991:    const _Tp height = a.height - b.height;
        -: 1992:    CV_DbgAssert(width >= 0 && height >= 0);
        -: 1993:    return Rect_<_Tp>( a.x, a.y, width, height );
        -: 1994:}
        -: 1995:
        -: 1996:template<typename _Tp> static inline
        -: 1997:Rect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 1998:{
        -: 1999:    Rect_<_Tp> c = a;
        -: 2000:    return c &= b;
        -: 2001:}
        -: 2002:
        -: 2003:template<typename _Tp> static inline
        -: 2004:Rect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)
        -: 2005:{
        -: 2006:    Rect_<_Tp> c = a;
        -: 2007:    return c |= b;
        -: 2008:}
        -: 2009:
        -: 2010:/**
        -: 2011: * @brief measure dissimilarity between two sample sets
        -: 2012: *
        -: 2013: * computes the complement of the Jaccard Index as described in <https://en.wikipedia.org/wiki/Jaccard_index>.
        -: 2014: * For rectangles this reduces to computing the intersection over the union.
        -: 2015: */
        -: 2016:template<typename _Tp> static inline
        -: 2017:double jaccardDistance(const Rect_<_Tp>& a, const Rect_<_Tp>& b) {
        -: 2018:    _Tp Aa = a.area();
        -: 2019:    _Tp Ab = b.area();
        -: 2020:
        -: 2021:    if ((Aa + Ab) <= std::numeric_limits<_Tp>::epsilon()) {
        -: 2022:        // jaccard_index = 1 -> distance = 0
        -: 2023:        return 0.0;
        -: 2024:    }
        -: 2025:
        -: 2026:    double Aab = (a & b).area();
        -: 2027:    // distance = 1 - jaccard_index
        -: 2028:    return 1.0 - Aab / (Aa + Ab - Aab);
        -: 2029:}
        -: 2030:
        -: 2031:/** @brief Finds out if there is any intersection between two rectangles
        -: 2032: *
        -: 2033: * mainly useful for language bindings
        -: 2034: * @param a First rectangle
        -: 2035: * @param b Second rectangle
        -: 2036: * @return the area of the intersection
        -: 2037: */
        -: 2038:CV_EXPORTS_W inline double rectangleIntersectionArea(const Rect2d& a, const Rect2d& b) { return (a & b).area(); }
        -: 2039:
        -: 2040:////////////////////////////// RotatedRect //////////////////////////////
        -: 2041:
        -: 2042:inline
        -: 2043:RotatedRect::RotatedRect()
        -: 2044:    : center(), size(), angle(0) {}
        -: 2045:
        -: 2046:inline
        -: 2047:RotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)
        -: 2048:    : center(_center), size(_size), angle(_angle) {}
        -: 2049:
        -: 2050:///////////////////////////////// Range /////////////////////////////////
        -: 2051:
        -: 2052:inline
        -: 2053:Range::Range()
        -: 2054:    : start(0), end(0) {}
        -: 2055:
        -: 2056:inline
        -: 2057:Range::Range(int _start, int _end)
        -: 2058:    : start(_start), end(_end) {}
        -: 2059:
        -: 2060:inline
        -: 2061:int Range::size() const
        -: 2062:{
        -: 2063:    return end - start;
        -: 2064:}
        -: 2065:
        -: 2066:inline
        -: 2067:bool Range::empty() const
        -: 2068:{
        -: 2069:    return start == end;
        -: 2070:}
        -: 2071:
        -: 2072:inline
        -: 2073:Range Range::all()
        -: 2074:{
        -: 2075:    return Range(INT_MIN, INT_MAX);
        -: 2076:}
        -: 2077:
        -: 2078:
        -: 2079:static inline
        -: 2080:bool operator == (const Range& r1, const Range& r2)
        -: 2081:{
        -: 2082:    return r1.start == r2.start && r1.end == r2.end;
        -: 2083:}
        -: 2084:
        -: 2085:static inline
        -: 2086:bool operator != (const Range& r1, const Range& r2)
        -: 2087:{
        -: 2088:    return !(r1 == r2);
        -: 2089:}
        -: 2090:
        -: 2091:static inline
        -: 2092:bool operator !(const Range& r)
        -: 2093:{
        -: 2094:    return r.start == r.end;
        -: 2095:}
        -: 2096:
        -: 2097:static inline
        -: 2098:Range operator & (const Range& r1, const Range& r2)
        -: 2099:{
        -: 2100:    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));
        -: 2101:    r.end = std::max(r.end, r.start);
        -: 2102:    return r;
        -: 2103:}
        -: 2104:
        -: 2105:static inline
        -: 2106:Range& operator &= (Range& r1, const Range& r2)
        -: 2107:{
        -: 2108:    r1 = r1 & r2;
        -: 2109:    return r1;
        -: 2110:}
        -: 2111:
        -: 2112:static inline
        -: 2113:Range operator + (const Range& r1, int delta)
        -: 2114:{
        -: 2115:    return Range(r1.start + delta, r1.end + delta);
        -: 2116:}
        -: 2117:
        -: 2118:static inline
        -: 2119:Range operator + (int delta, const Range& r1)
        -: 2120:{
        -: 2121:    return Range(r1.start + delta, r1.end + delta);
        -: 2122:}
        -: 2123:
        -: 2124:static inline
        -: 2125:Range operator - (const Range& r1, int delta)
        -: 2126:{
        -: 2127:    return r1 + (-delta);
        -: 2128:}
        -: 2129:
        -: 2130:
        -: 2131:
        -: 2132:///////////////////////////////// Scalar ////////////////////////////////
        -: 2133:
        -: 2134:template<typename _Tp> inline
        -: 2135:Scalar_<_Tp>::Scalar_()
        -: 2136:{
        -: 2137:    this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0;
        -: 2138:}
        -: 2139:
        -: 2140:template<typename _Tp> inline
        -: 2141:Scalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)
        -: 2142:{
        -: 2143:    this->val[0] = v0;
        -: 2144:    this->val[1] = v1;
        -: 2145:    this->val[2] = v2;
        -: 2146:    this->val[3] = v3;
        -: 2147:}
        -: 2148:
        -: 2149:template<typename _Tp> inline
        -: 2150:Scalar_<_Tp>::Scalar_(const Scalar_<_Tp>& s) : Vec<_Tp, 4>(s) {
        -: 2151:}
        -: 2152:
        -: 2153:template<typename _Tp> inline
        -: 2154:Scalar_<_Tp>::Scalar_(Scalar_<_Tp>&& s) CV_NOEXCEPT {
        -: 2155:    this->val[0] = std::move(s.val[0]);
        -: 2156:    this->val[1] = std::move(s.val[1]);
        -: 2157:    this->val[2] = std::move(s.val[2]);
        -: 2158:    this->val[3] = std::move(s.val[3]);
        -: 2159:}
        -: 2160:
        -: 2161:template<typename _Tp> inline
        -: 2162:Scalar_<_Tp>& Scalar_<_Tp>::operator=(const Scalar_<_Tp>& s) {
        -: 2163:    this->val[0] = s.val[0];
        -: 2164:    this->val[1] = s.val[1];
        -: 2165:    this->val[2] = s.val[2];
        -: 2166:    this->val[3] = s.val[3];
        -: 2167:    return *this;
        -: 2168:}
        -: 2169:
        -: 2170:template<typename _Tp> inline
        -: 2171:Scalar_<_Tp>& Scalar_<_Tp>::operator=(Scalar_<_Tp>&& s) CV_NOEXCEPT {
        -: 2172:    this->val[0] = std::move(s.val[0]);
        -: 2173:    this->val[1] = std::move(s.val[1]);
        -: 2174:    this->val[2] = std::move(s.val[2]);
        -: 2175:    this->val[3] = std::move(s.val[3]);
        -: 2176:    return *this;
        -: 2177:}
        -: 2178:
        -: 2179:template<typename _Tp> template<typename _Tp2, int cn> inline
        -: 2180:Scalar_<_Tp>::Scalar_(const Vec<_Tp2, cn>& v)
        -: 2181:{
        -: 2182:    int i;
        -: 2183:    for( i = 0; i < (cn < 4 ? cn : 4); i++ )
        -: 2184:        this->val[i] = cv::saturate_cast<_Tp>(v.val[i]);
        -: 2185:    for( ; i < 4; i++ )
        -: 2186:        this->val[i] = 0;
        -: 2187:}
        -: 2188:
        -: 2189:template<typename _Tp> inline
        -: 2190:Scalar_<_Tp>::Scalar_(_Tp v0)
        -: 2191:{
        -: 2192:    this->val[0] = v0;
        -: 2193:    this->val[1] = this->val[2] = this->val[3] = 0;
        -: 2194:}
        -: 2195:
        -: 2196:template<typename _Tp> inline
        -: 2197:Scalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)
        -: 2198:{
        -: 2199:    return Scalar_<_Tp>(v0, v0, v0, v0);
        -: 2200:}
        -: 2201:
        -: 2202:
        -: 2203:template<typename _Tp> inline
        -: 2204:Scalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& a, double scale ) const
        -: 2205:{
        -: 2206:    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0] * a.val[0] * scale),
        -: 2207:                        saturate_cast<_Tp>(this->val[1] * a.val[1] * scale),
        -: 2208:                        saturate_cast<_Tp>(this->val[2] * a.val[2] * scale),
        -: 2209:                        saturate_cast<_Tp>(this->val[3] * a.val[3] * scale));
        -: 2210:}
        -: 2211:
        -: 2212:template<typename _Tp> inline
        -: 2213:Scalar_<_Tp> Scalar_<_Tp>::conj() const
        -: 2214:{
        -: 2215:    return Scalar_<_Tp>(saturate_cast<_Tp>( this->val[0]),
        -: 2216:                        saturate_cast<_Tp>(-this->val[1]),
        -: 2217:                        saturate_cast<_Tp>(-this->val[2]),
        -: 2218:                        saturate_cast<_Tp>(-this->val[3]));
        -: 2219:}
        -: 2220:
        -: 2221:template<typename _Tp> inline
        -: 2222:bool Scalar_<_Tp>::isReal() const
        -: 2223:{
        -: 2224:    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;
        -: 2225:}
        -: 2226:
        -: 2227:
        -: 2228:template<typename _Tp> template<typename T2> inline
        -: 2229:Scalar_<_Tp>::operator Scalar_<T2>() const
        -: 2230:{
        -: 2231:    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),
        -: 2232:                       saturate_cast<T2>(this->val[1]),
        -: 2233:                       saturate_cast<T2>(this->val[2]),
        -: 2234:                       saturate_cast<T2>(this->val[3]));
        -: 2235:}
        -: 2236:
        -: 2237:
        -: 2238:template<typename _Tp> static inline
        -: 2239:Scalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2240:{
        -: 2241:    a.val[0] += b.val[0];
        -: 2242:    a.val[1] += b.val[1];
        -: 2243:    a.val[2] += b.val[2];
        -: 2244:    a.val[3] += b.val[3];
        -: 2245:    return a;
        -: 2246:}
        -: 2247:
        -: 2248:template<typename _Tp> static inline
        -: 2249:Scalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2250:{
        -: 2251:    a.val[0] -= b.val[0];
        -: 2252:    a.val[1] -= b.val[1];
        -: 2253:    a.val[2] -= b.val[2];
        -: 2254:    a.val[3] -= b.val[3];
        -: 2255:    return a;
        -: 2256:}
        -: 2257:
        -: 2258:template<typename _Tp> static inline
        -: 2259:Scalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )
        -: 2260:{
        -: 2261:    a.val[0] *= v;
        -: 2262:    a.val[1] *= v;
        -: 2263:    a.val[2] *= v;
        -: 2264:    a.val[3] *= v;
        -: 2265:    return a;
        -: 2266:}
        -: 2267:
        -: 2268:template<typename _Tp> static inline
        -: 2269:bool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
        -: 2270:{
        -: 2271:    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&
        -: 2272:           a.val[2] == b.val[2] && a.val[3] == b.val[3];
        -: 2273:}
        -: 2274:
        -: 2275:template<typename _Tp> static inline
        -: 2276:bool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )
        -: 2277:{
        -: 2278:    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||
        -: 2279:           a.val[2] != b.val[2] || a.val[3] != b.val[3];
        -: 2280:}
        -: 2281:
        -: 2282:template<typename _Tp> static inline
        -: 2283:Scalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2284:{
        -: 2285:    return Scalar_<_Tp>(a.val[0] + b.val[0],
        -: 2286:                        a.val[1] + b.val[1],
        -: 2287:                        a.val[2] + b.val[2],
        -: 2288:                        a.val[3] + b.val[3]);
        -: 2289:}
        -: 2290:
        -: 2291:template<typename _Tp> static inline
        -: 2292:Scalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2293:{
        -: 2294:    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),
        -: 2295:                        saturate_cast<_Tp>(a.val[1] - b.val[1]),
        -: 2296:                        saturate_cast<_Tp>(a.val[2] - b.val[2]),
        -: 2297:                        saturate_cast<_Tp>(a.val[3] - b.val[3]));
        -: 2298:}
        -: 2299:
        -: 2300:template<typename _Tp> static inline
        -: 2301:Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)
        -: 2302:{
        -: 2303:    return Scalar_<_Tp>(a.val[0] * alpha,
        -: 2304:                        a.val[1] * alpha,
        -: 2305:                        a.val[2] * alpha,
        -: 2306:                        a.val[3] * alpha);
        -: 2307:}
        -: 2308:
        -: 2309:template<typename _Tp> static inline
        -: 2310:Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)
        -: 2311:{
        -: 2312:    return a*alpha;
        -: 2313:}
        -: 2314:
        -: 2315:template<typename _Tp> static inline
        -: 2316:Scalar_<_Tp> operator - (const Scalar_<_Tp>& a)
        -: 2317:{
        -: 2318:    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]),
        -: 2319:                        saturate_cast<_Tp>(-a.val[1]),
        -: 2320:                        saturate_cast<_Tp>(-a.val[2]),
        -: 2321:                        saturate_cast<_Tp>(-a.val[3]));
        -: 2322:}
        -: 2323:
        -: 2324:
        -: 2325:template<typename _Tp> static inline
        -: 2326:Scalar_<_Tp> operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2327:{
        -: 2328:    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),
        -: 2329:                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),
        -: 2330:                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),
        -: 2331:                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));
        -: 2332:}
        -: 2333:
        -: 2334:template<typename _Tp> static inline
        -: 2335:Scalar_<_Tp>& operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2336:{
        -: 2337:    a = a * b;
        -: 2338:    return a;
        -: 2339:}
        -: 2340:
        -: 2341:template<typename _Tp> static inline
        -: 2342:Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)
        -: 2343:{
        -: 2344:    return Scalar_<_Tp>(a.val[0] / alpha,
        -: 2345:                        a.val[1] / alpha,
        -: 2346:                        a.val[2] / alpha,
        -: 2347:                        a.val[3] / alpha);
        -: 2348:}
        -: 2349:
        -: 2350:template<typename _Tp> static inline
        -: 2351:Scalar_<float> operator / (const Scalar_<float>& a, float alpha)
        -: 2352:{
        -: 2353:    float s = 1 / alpha;
        -: 2354:    return Scalar_<float>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
        -: 2355:}
        -: 2356:
        -: 2357:template<typename _Tp> static inline
        -: 2358:Scalar_<double> operator / (const Scalar_<double>& a, double alpha)
        -: 2359:{
        -: 2360:    double s = 1 / alpha;
        -: 2361:    return Scalar_<double>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);
        -: 2362:}
        -: 2363:
        -: 2364:template<typename _Tp> static inline
        -: 2365:Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)
        -: 2366:{
        -: 2367:    a = a / alpha;
        -: 2368:    return a;
        -: 2369:}
        -: 2370:
        -: 2371:template<typename _Tp> static inline
        -: 2372:Scalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)
        -: 2373:{
        -: 2374:    _Tp s = a / (b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);
        -: 2375:    return b.conj() * s;
        -: 2376:}
        -: 2377:
        -: 2378:template<typename _Tp> static inline
        -: 2379:Scalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2380:{
        -: 2381:    return a * ((_Tp)1 / b);
        -: 2382:}
        -: 2383:
        -: 2384:template<typename _Tp> static inline
        -: 2385:Scalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)
        -: 2386:{
        -: 2387:    a = a / b;
        -: 2388:    return a;
        -: 2389:}
        -: 2390:
        -: 2391:template<typename _Tp> static inline
        -: 2392:Scalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)
        -: 2393:{
        -: 2394:    Matx<double, 4, 1> c((Matx<double, 4, 4>)a, b, Matx_MatMulOp());
        -: 2395:    return reinterpret_cast<const Scalar&>(c);
        -: 2396:}
        -: 2397:
        -: 2398:template<> inline
        -: 2399:Scalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)
        -: 2400:{
        -: 2401:    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());
        -: 2402:    return reinterpret_cast<const Scalar&>(c);
        -: 2403:}
        -: 2404:
        -: 2405:
        -: 2406:
        -: 2407://////////////////////////////// KeyPoint ///////////////////////////////
        -: 2408:
        -: 2409:inline
        -: 2410:KeyPoint::KeyPoint()
        -: 2411:    : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}
        -: 2412:
        -: 2413:inline
        -: 2414:KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)
        -: 2415:    : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}
        -: 2416:
        -: 2417:inline
        -: 2418:KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)
        -: 2419:    : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}
        -: 2420:
        -: 2421:
        -: 2422:
        -: 2423:///////////////////////////////// DMatch ////////////////////////////////
        -: 2424:
        -: 2425:inline
        -: 2426:DMatch::DMatch()
        -: 2427:    : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(FLT_MAX) {}
        -: 2428:
        -: 2429:inline
        -: 2430:DMatch::DMatch(int _queryIdx, int _trainIdx, float _distance)
        -: 2431:    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}
        -: 2432:
        -: 2433:inline
        -: 2434:DMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance)
        -: 2435:    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}
        -: 2436:
        -: 2437:inline
        -: 2438:bool DMatch::operator < (const DMatch &m) const
        -: 2439:{
        -: 2440:    return distance < m.distance;
        -: 2441:}
        -: 2442:
        -: 2443:
        -: 2444:
        -: 2445:////////////////////////////// TermCriteria /////////////////////////////
        -: 2446:
        -: 2447:inline
        -: 2448:TermCriteria::TermCriteria()
        -: 2449:    : type(0), maxCount(0), epsilon(0) {}
        -: 2450:
        -: 2451:inline
        -: 2452:TermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)
        -: 2453:    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}
        -: 2454:
        -: 2455://! @endcond
        -: 2456:
        -: 2457:} // cv
        -: 2458:
        -: 2459:#ifdef _MSC_VER
        -: 2460:#pragma warning(pop)
        -: 2461:#endif
        -: 2462:
        -: 2463:#endif //OPENCV_CORE_TYPES_HPP
